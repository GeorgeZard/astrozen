# Code Style and Conventions Standards for Astro

> From [CodingRules.ai](https://codingrules.ai/rules/code-style-and-conventions-standards-for-astro)

**Tags:** Astro

---

# Code Style and Conventions Standards for Astro

This document outlines the code style and conventions for Astro projects. Adhering to these standards improves code readability, maintainability, consistency, performance, and collaboration within development teams. These guidelines are crucial for both human developers and AI code assistants to generate high-quality Astro code.

## 1. General Principles

*   **Consistency:** Maintain a consistent style throughout the entire project.  Use tools (linters, formatters) to automate consistency.
*   **Readability:**  Prioritize code that is easy to read and understand. Use meaningful names, clear comments, and consistent indentation.
*   **Maintainability:** Write code that is easy to modify and extend.  Follow established design patterns and avoid complex, tightly coupled code.
*   **Performance:**  Write code that performs well. Optimize images, minimize JavaScript, and leverage Astro's features for static site generation.
*   **Security:**  Follow security best practices to prevent vulnerabilities like XSS and CSRF. Sanitize user input and escape output.

## 2. Formatting

### 2.1. General Formatting

*   **Indentation:** Use 2 spaces for indentation.  **Do This:**

    """astro
    ---
    const name = "Astro";
    ---

    <h1>Hello, {name}!</h1>
    """

    **Don't Do This:**

    """astro
    ---
    const name = "Astro";
    ---

    <h1>Hello, {name}!</h1>
    """

*   **Line Length:** Limit lines to a maximum of 120 characters. This improves readability, especially on smaller screens.
*   **Trailing Whitespace:** Remove all trailing whitespace. Most editors can be configured to do this automatically.
*   **Newlines:** End files with a newline character.
*   **File Encoding:** Use UTF-8 encoding for all files.
*   **Blank Lines:** Use blank lines to separate logical sections of code, improving readability.

### 2.2. Astro Component Formatting

*   **Component Structure:**  Organize components into three sections, separated by "---": frontmatter, template, and script.

    """astro
    ---
    // Frontmatter: data fetching, imports, logic
    import MyComponent from '../components/MyComponent.astro';

    const title = "My Astro Page";
    const myData = await getMyData(); //Example Data Fetch
    ---

    <html lang="en">
      <head>
        <title>{title}</title>
      </head>
      <body>
        <h1>{title}</h1>
        <MyComponent data={myData} /> // Use a component
        <script>
          // Client-side scripting (hydration, etc.)
          console.log('Page loaded!');
        </script>
      </body>
    </html>
    """

*   **Attribute Formatting:**  Keep HTML and component attributes on the same line if short. Break into multiple lines if the attribute list is long.

    """astro
    <!-- Short attributes, all on one line -->
    <img src="/image.jpg" alt="Description" />

    <!-- Long attributes, break into multiple lines -->
    <MyComponent
      title="Very Long Title That Might Wrap"
      description="An even longer description of the component"
      data={someComplexData}
    />
    """

*   **Curly Braces:**  Use curly braces "{}" for expressions within the template. Ensure proper spacing inside the braces.  **Do This:** "{ myVariable }".  **Don't Do This:** "{myVariable}".

*   **Component Imports:** Place all component imports in the frontmatter section.

### 2.3. CSS Formatting

*   **CSS Files:** Use separate CSS files for larger projects.

    """css
    /* styles.css */
    body {
      font-family: sans-serif;
      margin: 0;
    }

    h1 {
      color: blue;
    }
    """

*   **Inline Styles:**  Use inline styles sparingly and only for simple, component-specific styling. Extract to external stylesheets when reusability is needed.

    """astro
    <h1 style={{ color: 'red' }}>Inline Style</h1>
    """

*   **CSS-in-JS Libraries:** Consider using CSS-in-JS libraries like Styled Components or Emotion for more complex component styling.  However, be mindful of the increased bundle size and runtime overhead. Only use if the benefits (dynamic styling, component-level scoping) are truly needed.

*   **Specificity:** Keep CSS selectors specific and avoid excessive nesting and over-qualification.

### 2.4. JavaScript/TypeScript Formatting

*   **Semicolons:** Use semicolons at the end of statements.
*   **Quotes:** Use single quotes ("'") for strings.
*   **"const" and "let":**  Prefer "const" for variables that do not change and "let" for variables that do change. Avoid "var".
*   **Arrow Functions:** Use arrow functions where appropriate for concise syntax.

    """typescript
    const add = (a: number, b: number): number => a + b;
    """

*   **Type Annotations:**  Use TypeScript type annotations to improve code clarity and prevent errors.
*   **Modules:**  Use ES Modules ("import"/"export") for managing dependencies.
*   **Async/Await:**  Use "async"/"await" for asynchronous operations rather than callbacks or promises directly.

## 3. Naming Conventions

### 3.1. General Naming

*   **Descriptive Names:**  Use descriptive and meaningful names for variables, functions, and components.
*   **Camel Case:** Use camel case for variable and function names (e.g., "myVariableName", "getData").
*   **Pascal Case:** Use Pascal case for component names (e.g., "MyComponent", "UserProfile").
*   **File Names:** Use kebab case for file names (e.g., "my-component.astro", "user-profile.css").
*   **Constants:** Use SCREAMING_SNAKE_CASE for constants (e.g., "API_URL", "MAX_RETRIES").

### 3.2. Astro-Specific Naming

*   **Component Names:** Component names should clearly indicate their purpose. For example, "ProductCard" for a component displaying product information.
*   **Layout Names:** Layout components should use the "Layout" suffix, such as "BaseLayout".
*   **Page Names:** Page files should correspond to the URL route they represent (e.g., "index.astro" for the homepage, "about.astro" for the "/about" page).

## 4. Stylistic Consistency

### 4.1. Code Structure

*   **Component Organization:**  Organize components into logical directories based on functionality (e.g., "components/", "layouts/", "pages/").

    """
    src/
    ├── components/
    │   ├── ProductCard.astro
    │   ├── Button.astro
    │   └── ...
    ├── layouts/
    │   ├── BaseLayout.astro
    │   └── ...
    ├── pages/
    │   ├── index.astro
    │   ├── about.astro
    │   └── ...
    └── styles/
        └── global.css
    """

*   **Separation of Concerns:**  Separate concerns by dividing code into reusable components and modules.
*   **Single Responsibility Principle:** Each component/function should have a single, well-defined responsibility.

### 4.2. Template Syntax

*   **Consistent Use of Expressions:**  Use curly braces consistently for expressions within the HTML template.
*   **Component Composition:** Favor component composition over inheritance for creating reusable UI elements. This is a core tenet of modern component-based frameworks like Astro and React.

    """astro
    <!-- Reusable button component -->
    <Button>Click Me</Button>

    <!-- Button component definition -->
    ---
    // components/Button.astro
    ---
    <button class="my-button">
      <slot />
    </button>

    <style>
      .my-button {
        /* Button styles here */
      }
    </style>
    """

*   **Slots:** Master the use of slots to create flexible layouts, making components reusable.

### 4.3. Scripting

*   **Client-Side Scripting:** Minimize client-side JavaScript. Astro’s strength lies in its ability to generate static HTML. Only hydrate components when necessary for interactivity.  Use "client:" directives ("client:load", "client:visible", "client:idle", "client:media") to control when components are hydrated.

    """astro
    <!-- Hydrate the component when the page loads -->
    <MyInteractiveComponent client:load />

    <!-- Hydrate the component when it becomes visible in the viewport -->
    <MyInteractiveComponent client:visible />
    """

*   **Server-Side Logic:** Perform data fetching and complex logic on the server-side (in the frontmatter) whenever possible.

## 5. Modern Approaches and Patterns

### 5.1. Astro Islands Architecture

*   **Partial Hydration:** Embrace Astro's Islands Architecture by selectively hydrating components that require interactivity.  This reduces JavaScript overhead and improves performance.
*   **Client Directives:**  Use "client:" directives to control hydration strategies ("load", "visible", "idle", "media").  Choose the appropriate directive based on the component's requirements and the user experience.
*   **Progressive Enhancement:** Build the core functionality of your site using static HTML and CSS.  Enhance the experience with JavaScript where necessary.

### 5.2. Data Fetching

*   **"getStaticPaths()":**  Use "getStaticPaths()" for generating static pages from dynamic data.  This is a key feature for building performant, SEO-friendly sites.

    """astro
    // pages/posts/[id].astro
    export async function getStaticPaths() {
      const posts = await getPostsFromDatabase(); // Hypothetical function
      return posts.map((post) => ({
        params: { id: post.id },
        props: { post },
      }));
    }

    const { post } = Astro.props;

    ---
    <h1>{post.title}</h1>
    <p>{post.content}</p>
    """

*   **Content Collections:** Use Astro's content collections to manage and validate content.  This provides type safety and improves the developer experience.

    """typescript
    // src/content/config.ts
    import { defineCollection, z } from 'astro:content';

    const postsCollection = defineCollection({
      schema: z.object({
        title: z.string(),
        date: z.date(),
        description: z.string().optional(),
      }),
    });

    export const collections = {
      posts: postsCollection,
    };
    """

### 5.3. Component Libraries

*   **UI Component Libraries:** Build reusable UI component libraries for consistent styling and functionality.
*   **Utility-First CSS:** Consider using utility-first CSS frameworks like Tailwind CSS for rapid styling.
*   **Headless UI Libraries:** Integrate headless UI libraries like Radix UI for accessible and customizable components.

### 5.4. Integrations

*   **Official Integrations:** Leverage Astro's official integrations for enhanced functionality (React, Vue, Svelte, MDX, Tailwind).
*   **Community Integrations:** Explore community integrations for specific needs.
*   **Custom Integrations:** Build custom integrations to extend Astro's capabilities.

## 6. Common Anti-Patterns and Mistakes

*   **Over-Hydration:**  Hydrating too many components or hydrating them unnecessarily.
*   **Large JavaScript Bundles:**  Failing to optimize JavaScript bundles, leading to slow page load times.
*   **Ignoring SEO:**  Not optimizing the site for search engines (missing meta tags, poor content structure).
*   **Not Using Content Collections:**  Manually managing content instead of using Astro's content collections.
*   **Deeply Nested Components:** Creating overly complex component hierarchies, making code difficult to understand and maintain.
*   **Mixing concerns:** Combining data fetching, logic and presentation in the same component.

## 7. Performance Optimization

*   **Image Optimization:**  Optimize images by compressing them and using appropriate formats (WebP, AVIF).  Use Astro's image component for automatic optimization.

    """astro
    <!-- Use Astro's image component -->
    <Image src={myImage} alt="Description" width={600} height={400} />
    """

*   **Code Splitting:**  Split JavaScript bundles into smaller chunks to improve initial load time.
*   **Lazy Loading:**  Lazy load images and other resources that are not immediately visible.
*   **Caching:**  Leverage browser caching and CDN caching to reduce server load and improve performance.

## 8. Security Best Practices

*   **Sanitize User Input:**  Sanitize user input to prevent XSS vulnerabilities.
*   **Escape Output:**  Escape output to prevent HTML injection attacks.
*   **Use HTTPS:**  Use HTTPS to encrypt communication between the client and server.
*   **Content Security Policy (CSP):** Implement a CSP to restrict the sources from which resources can be loaded.
*   **Regularly Update Dependencies:** Keep dependencies up to date to patch security vulnerabilities.
*   **Avoid eval()**:  Never utilize "eval()" function to mitigate remote code execution vulnerabilities.

## 9. Tooling

*   **ESLint:** Use ESLint to enforce code style rules and prevent errors. Configure with community or custom Astro-specific rules.
*   **Prettier:** Use Prettier to automatically format code.
*   **TypeScript:** Use TypeScript for type checking and improved code quality.
*   **Visual Studio Code (VS Code):**  Use VS Code with the Astro extension for syntax highlighting, code completion, and other helpful features.
*   **GitHub Actions:**  Use GitHub Actions for CI/CD, including linting, formatting, and testing. Add a pre-commit hook to enforce formatting and linting before commits.
*   **Remark and Rehype:** Use these tools for automated content modification and validation for markdown files.

## 10. Documentation

*   **Code Comments:**  Write clear and concise code comments to explain complex logic and non-obvious code.
*   **Component Documentation:**  Document components with JSDoc-style comments to explain their props and usage. Use a documentation generator like Storybook to create interactive component documentation.
*   **Project README:**  Provide a comprehensive README file with instructions on how to set up, run, and contribute to the project.

By consistently adhering to these code style and conventions, both human developers and AI coding assistants can contribute to creating high-quality, maintainable, and performant Astro projects.
# Core Architecture Standards for Astro

This document outlines the core architectural standards for Astro projects. These standards are designed to promote maintainability, scalability, performance, and security. Following these guidelines will help ensure consistency across projects and facilitate collaboration among developers. This document assumes familiarity with Astro's fundamental concepts. Focus will be on using the newest features and avoiding legacy patterns.

## 1. Project Structure and Organization

A well-defined project structure is crucial for maintainability and scalability.  Consistency in how we organize our code lets us navigate any Astro project quickly.

**Standards:**

*   **Do This:** Adhere to a modular and component-based architecture. Organize code into reusable components.
*   **Don't Do This:** Create monolithic structures that intertwine functionality, making components difficult to reuse and test.
*   **Why:** Modularity promotes separation of concerns, improving code readability, testability, and reusability. Component-based structure is fundamental to Astro's design.

### 1.1 "src/" Directory

The "src/" directory is the heart of an Astro project, containing all the project's source code.

**Standards:**

*   **Do This:** Structure the "src/" directory with the following subdirectories:
    *   "components/": Reusable UI components (Astro components, React, Vue, Svelte, etc.).
    *   "layouts/": Page layouts.
    *   "pages/": Routes and page definitions. Each ".astro" file here represents a page.
    *   "content/": Content collections for structured data (blog posts, documentation, etc.).
    *   "utils/": Utility functions.
    *   "styles/": Global styles and themes.
    *   "scripts/":  Client-side JavaScript.

*   **Don't Do This:** Place all code directly into the "src/" directory or create an unstructured mess. Also, avoid inconsistent naming conventions for directories.

*   **Why:** A predictable structure improves navigation and code discoverability.

**Example:**

"""
astro-project/
├── src/
│   ├── components/
│   │   ├── Card.astro
│   │   └── Button.jsx
│   ├── layouts/
│   │   ├── BaseLayout.astro
│   │   └── BlogPostLayout.astro
│   ├── pages/
│   │   ├── index.astro
│   │   ├── about.astro
│   │   └── blog/[slug].astro
│   ├── content/
│   │   ├── blog/
│   │   │   ├── first-post.mdx
│   │   │   └── second-post.mdx
│   │   └── config.ts
│   ├── utils/
│   │   ├── date-formatter.ts
│   │   └── api-client.js
│   ├── styles/
│   │   ├── global.css
│   │   └── theme.css
│   └── scripts/
│       └── app.js
├── astro.config.mjs
├── package.json
└── tsconfig.json

"""

### 1.2 Component Organization

Consistent component structure and naming are essential.

**Standards:**

*   **Do This:**
    *   Use PascalCase for component filenames (e.g., "MyComponent.astro").
    *   Group related components in directories within "src/components/".
    *   Create a "index.astro" or "index.jsx" file within component directories to export the main component, allowing for shorter import paths.
*   **Don't Do This:** Use inconsistent naming schemes or scatter components throughout the project.
*   **Why:** Improves readability and simplifies component imports.

**Example:**

"""
src/components/
├── Blog/
│   ├── BlogPostCard.astro
│   ├── BlogPostList.astro
│   └── index.astro // Exports BlogPostList & BlogPostCard
└── UI/
    ├── Button.jsx
    ├── Input.jsx
    └── index.jsx // Exports Button & Input
"""

**Import Example:**

"""astro
---
import { BlogPostList } from '@components/Blog'; //Importing from the Blog component
---

<BlogPostList />
"""

### 1.3 Content Collections

Astro's content collections are a powerful way to manage structured content.

**Standards:**

*   **Do This:**
    *   Use content collections for blog posts, documentation, and other structured data.
    *   Define schemas for your content collections using Zod to ensure data consistency.
    *   Utilize the "getCollection()" function to query content within your components.
*   **Don't Do This:** Hardcode content directly into components or forgo defining schemas for collections.
*   **Why:** Provides data validation and type safety, improving content management.

**Example:**

"src/content/config.ts"

"""typescript
import { defineCollection, z } from 'astro:content';

const blogCollection = defineCollection({
  schema: z.object({
    title: z.string(),
    date: z.date(),
    author: z.string(),
    draft: z.boolean().default(false),
    tags: z.array(z.string()).optional(),
    description: z.string(),
    image: z.string().optional()
  }),
});

export const collections = {
  'blog': blogCollection,
};
"""

"src/pages/blog/[slug].astro"

"""astro
---
import { getCollection, getEntryBySlug } from 'astro:content';
import { format } from 'date-fns';

export async function getStaticPaths() {
  const blogPosts = await getCollection('blog');
  return blogPosts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }));
}

const { post } = Astro.props;
const { Content } = await post.render();
---

<html lang="en">
  <head>
    <title>{post.data.title}</title>
  </head>
  <body>
    <article>
      <h1>{post.data.title}</h1>
      <p>Published on: {format(post.data.date, 'MMMM dd, yyyy')}</p>
      <Content />
    </article>
  </body>
</html
"""

## 2. Component Design and Implementation

Effective component design is fundamental to building maintainable Astro applications.

**Standards:**

*   **Do This:** Follow the principles of single responsibility, separation of concerns, and loose coupling when designing components.
*   **Don't Do This:** Create overly complex components or ones with dependencies that are hard to manage.
*   **Why:** Facilitates code maintenance, testing, and reuse.

### 2.1 Astro Component Best Practices

Astro components should be self-contained and reusable.

**Standards:**

*   **Do This:**
    *   Use props to pass data into components. Use prop destructuring for improved readability.
    *   Utilize the client directives ("client:load", "client:idle", "client:visible", "client:only") to optimize JavaScript loading and execution. SSR first.
    *  Use Slots to allow users of your components to inject HTML and other components.
*   **Don't Do This:** Directly modify global state within components or tightly couple components to specific data sources.
*   **Why:** Promotes component reusability and testability.

**Example:**

"""astro
---
// src/components/Card.astro
interface Props {
  title: string;
  body: string;
  href: string;
}

const { title, body, href } = Astro.props;
---

<a href={href} class="card">
  <h3>
    {title}
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
    </svg>
  </h3>
  <p>{body}</p>
</a>
<style>
  .card {
    /* Styles... */
  }
</style>
"""

"""astro
// src/pages/index.astro
---
import Card from '../components/Card.astro';
---

<Card
  title="Astro"
  body="Learn more about Astro"
  href="https://astro.build/"
/>
"""

### 2.2. Using Client Directives

Astro's client directives control when and how JavaScript is loaded and executed.

**Standards:**

*   **Do This:**
    *   Use "client:load" for components that need to be interactive as soon as possible.
    *   Use "client:idle" for components that can wait until the browser is idle.
    *   Use "client:visible" for components that should load when they become visible in the viewport.
    *   Use "client:only" *sparingly* and only when necessary for UI frameworks that are not server-renderable at all.
    *   Default to server-side rendering when interactivity isn't required.
*   **Don't Do This:** Load all JavaScript eagerly using "client:load" if it is not necessary (hurts performance).
*   **Why:** Optimizes page load performance by deferring the loading of non-critical JavaScript.

**Example:**

"""jsx
// src/components/Counter.jsx
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
"""

"""astro
// src/pages/index.astro
---
import Counter from '../components/Counter.jsx';
---

<Counter client:idle />
"""

### 2.3 Styling Components

Use modular and maintainable styling approaches.

**Standards:**

*   **Do This:**
    *   Use CSS modules, styled components, or utility-first CSS frameworks (Tailwind CSS) for component-specific styling.
    *   Use global CSS files ("src/styles/global.css") for base styles and theming.
    *   Leveraging Astro's built-in CSS scoping for ".astro" components.
*   **Don't Do This:** Write inline styles directly into components (except for highly specific, dynamic cases) or pollute the global namespace with un-scoped CSS.
*   **Why:** Improves style isolation, reusability, and maintainability.

**Example (CSS Modules):**

"""jsx
// src/components/Button.jsx
import styles from './Button.module.css';

export default function Button({ children, onClick }) {
  return (
    <button className={styles.button} onClick={onClick}>
      {children}
    </button>
  );
}
"""

"""css
/* src/components/Button.module.css */
.button {
  background-color: #007bff;
  color: white;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
}

.button:hover {
  background-color: #0056b3;
}
"""

**Example (Tailwind CSS):**

"""jsx
// src/components/Button.jsx
export default function Button({ children, onClick }) {
  return (
    <button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" onClick={onClick}>
      {children}
    </button>
  );
}
"""

**Example (Astro Component scoping):**

"""astro
---
// src/components/MyComponent.astro

---
<div class='container'>
  <p>Styled paragraph</p>
</div>

<style>
  .container {
    border: 1px solid red;
  }

  p {
    color: blue;
  }
</style>
"""

The CSS rules are scoped to the "<MyComponent>" component.

## 3. Data Fetching and Management

Efficient data fetching and management are critical for performance.

**Standards:**

*   **Do This:** Use Astro's built-in "fetch()" API or other data-fetching libraries (e.g., "axios", "ky") to retrieve data. Use content collections for local data. Implement caching strategies to avoid unnecessary requests.
*   **Don't Do This:** Perform data fetching directly within client-side components (except when absolutely necessary) or neglect implementing caching.
*   **Why:** Improves performance and reduces network load.

### 3.1 Server-Side Data Fetching

Where possible, fetch data on the server.

**Standards:**

*   **Do This:** Fetch data within "getStaticPaths()" or directly in your Astro component's frontmatter when possible. Use environment variables to securely store API keys.
*   **Don't Do This:** Expose API keys directly in your client-side code.
*   **Why:** Prevents exposing sensitive data to the client and improves security.

**Example:**

"""astro
---
// src/pages/index.astro
import { getPosts } from '../utils/api-client';

const posts = await getPosts();
---

<ul>
  {posts.map((post) => (
    <li>{post.title}</li>
  ))}
</ul>
"""

"""javascript
// src/utils/api-client.js
const API_URL = import.meta.env.API_URL;

export async function getPosts() {
  const res = await fetch("${API_URL}/posts");
  const data = await res.json();
  return data;
}
"""

### 3.2 Caching Strategies

Effective caching can significantly improve performance.

**Standards:**

*   **Do This:** Utilize HTTP caching headers, service workers, or in-memory caching to store frequently accessed data.
*   **Don't Do This:** Neglect implementing caching mechanisms.
*   **Why:** Reduces network requests and improves response times.

**Example (HTTP Caching):**

Set appropriate "Cache-Control" headers on your API responses.

"""javascript
//Example Node.js server
app.get('/api/posts', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
  // code to fetch and send posts
});
"""

## 4. Error Handling and Logging

Robust error handling and logging are essential for tracking down bugs in production

**Standards:**

*   **Do This:** Implement comprehensive error handling mechanisms using "try...catch" blocks and Astro's "onError" hook. Implement a logging strategy using a service like Sentry or a custom logging mechanism.
*   **Don't Do This:** Allow errors to go unhandled or neglect implementing logging.
*   **Why:** Improves application resilience and helps diagnose issues.

### 4.1 Error Boundaries

Using error boundaries within components to catch errors and present fallback UI. Note that framework-specific boundaries ("React.ErrorBoundary", "Vue's onErrorCaptured") can be leveraged with Astro islands.

**Example:**

"""jsx
// src/components/ErrorBoundary.jsx (React Example)
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Caught error: ", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
"""

"""astro
// src/pages/index.astro
---
import ErrorBoundary from '../components/ErrorBoundary.jsx';
import MyComponent from '../components/MyComponent.jsx';
---

<ErrorBoundary client:visible>
  <MyComponent client:visible />
</ErrorBoundary>
"""

### 4.2 Logging

Implement a comprehensive logging strategy.

**Standards:**

*   **Do This:** Use a logging service like Sentry or implement a custom logging mechanism. Log errors, warnings, and informational messages. Use environment variables to configure logging levels.
*   **Don't Do This:** Log sensitive information or neglect implementing logging.
*   **Why:** Helps diagnose issues and track application health.

**Example (Sentry):**

"""javascript
// src/scripts/sentry.js
import * as Sentry from "@sentry/browser";

Sentry.init({
  dsn: import.meta.env.SENTRY_DSN,
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay()
  ],
  // Performance Monitoring
  tracesSampleRate: 0.1, // Capture 10% of transactions for performance monitoring.
  // Session Replay
  replaysSessionSampleRate: 0.1, // This sets the sample rate at 10%. You may want to lower it at first.
  replaysOnErrorSampleRate: 1.0, // If you're not already sampling the entire session, change the sample rate to 100% when sampling sessions where errors occur.
});
"""

"""astro
// src/layouts/BaseLayout.astro
---
import '../scripts/sentry.js';//Initialize sentry in a base layout
---
"""

## 5. Accessibility (a11y)

Building accessible websites is a crucial aspect of inclusive design.

**Standards:**

*   **Do This:** Follow accessibility guidelines like WCAG (Web Content Accessibility Guidelines). Use semantic HTML, provide alternative text for images, and ensure sufficient color contrast. Test your website with accessibility tools like Axe.
*   **Don't Do This:** Neglect accessibility considerations or create websites that are difficult for users with disabilities to navigate.
*   **Why:** Ensures that your website is usable by everyone, regardless of their abilities. Also, good for SEO.

### 5.1 Semantic HTML

Use semantic HTML elements to provide structure and meaning to your content.

**Standards:**

*   **Do This:** Use elements like "<article>", "<nav>", "<aside>", "<header>", "<footer>", "<main>", and "<section>" appropriately.
*   **Don't Do This:** Use generic "<div>" elements for everything.
*   **Why:** Improves accessibility and SEO.

**Example:**

"""astro
<header>
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/about">About</a></li>
      <li><a href="/blog">Blog</a></li>
    </ul>
  </nav>
</header>
<main>
  <article>
    <h1>My Blog Post</h1>
    <p>Content of the blog post.</p>
  </article>
</main>
<footer>
  <p>© 2024 My Website</p>
</footer>
"""

### 5.2 ARIA Attributes

Use ARIA (Accessible Rich Internet Applications) attributes to enhance accessibility.

**Standards:**

*   **Do This:** Use ARIA attributes to provide additional information to assistive technologies when semantic HTML is not sufficient.
*   **Don't Do This:** Overuse ARIA attributes or use them incorrectly.
*   **Why:** Improves accessibility for users with disabilities.

**Example:**

"""jsx
// src/components/CustomButton.jsx
export default function CustomButton({ onClick, children, ariaLabel }) {
  return (
    <button onClick={onClick} aria-label={ariaLabel}>
      {children}
    </button>
  );
}
"""

### 5.3 Image Alt Text

Provide alternative text for images to describe their content.

**Standards:**

*   **Do This:** Add "alt" attributes to all "<img>" elements. The "alt" text should be concise and descriptive.
*   **Don't Do This:** Leave "alt" attributes empty or use generic descriptions like "image".
*   **Why:** Improves accessibility for users who cannot see the images.

**Example:**

"""astro
<img src="/images/my-image.jpg" alt="A beautiful sunset over the ocean" />
"""

## 6. Security

Security is paramount. Adhere to security best practices to protect your application and users.

**Standards:**

*   **Do This:** Sanitize user inputs, use HTTPS, protect against Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks. Use secure coding practices.
*   **Don't Do This:** Store sensitive information in client-side code or neglect implementing security measures.
*   **Why:** Protects your application and users from security vulnerabilities and attacks.

### 6.1 Input Sanitization

Sanitize user inputs to prevent XSS attacks.

**Standards:**

*   **Do This:** Use a library like "DOMPurify" to sanitize user inputs before rendering them in your Astro components.
*   **Don't Do This:** Directly render user inputs without sanitization.
*   **Why:** Prevents attackers from injecting malicious scripts into your application.

**Example:**

"""javascript
// src/utils/sanitize.js
import DOMPurify from 'dompurify';

export function sanitize(html) {
  return DOMPurify.sanitize(html);
}
"""

"""astro
---
// src/pages/index.astro
import { sanitize } from '../utils/sanitize';

const userInput = "<script>alert('XSS');</script>Hello!";
const sanitizedInput = sanitize(userInput);
---

<p set:html={sanitizedInput} />
"""

### 6.2 HTTPS

Always use HTTPS to encrypt communication between the client and server.

**Standards:**

*   **Do This:** Configure your server to use HTTPS. Obtain an SSL/TLS certificate from a trusted certificate authority.
*   **Don't Do This:** Use HTTP in production.
*   **Why:** Protects data in transit from eavesdropping and tampering.

### 6.3 Environment Variables

Never directly expose sensitive information (API keys, database passwords, etc.) in your client-side code.

**Standards:**

*   **Do This:** Store all sensitive information in environment variables. Access environment variables using "import.meta.env". Ensure ".env" files are not committed to source control.
*   **Don't Do This:** Hardcode sensitive information in your code directly.
*   **Why:** prevents sensitive information from being exposed.

**Example:**

"""javascript
// .env
API_KEY=your_api_key
DATABASE_URL=your_database_url
"""

"""javascript
// src/utils/api-client.js
const API_KEY = import.meta.env.API_KEY;

export async function fetchData() {
  const res = await fetch("/api/data?apiKey=${API_KEY}");
  const data = await res.json();
  return data;
}
"""

These core architecture standards for Astro are designed to enable the creation of high-quality, maintainable, and scalable applications. Adherence to these standards will ensure consistency, improve collaboration, and contribute to the long-term success of Astro projects.
# Component Design Standards for Astro

This document outlines the component design standards for Astro projects. These standards promote maintainability, reusability, performance, and a consistent development experience across teams. It leverages the latest Astro features and best practices.

## 1. Component Architecture

### 1.1 Modularity and Reusability

**Standard:** Components should be designed as independent, reusable units of functionality.

**Do This:**

*   Create components with a single, well-defined responsibility.
*   Favor composition over inheritance. Use Astro's component slot and props functionalities to allow customization.
*   Store reusable components in a dedicated directory (e.g., "src/components").

**Don't Do This:**

*   Create monolithic components that handle multiple unrelated tasks.
*   Duplicate code across components. Extract common logic into shared components or utility functions.

**Why:** Modular components are easier to understand, test, and maintain. Reusable components reduce code duplication and development time.

**Example:**

"""astro
// src/components/Button.astro
---
interface Props {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  text: string;
  onClick?: () => void;
}

const { variant = 'primary', size = 'medium', text, onClick } = Astro.props;

const buttonClasses = {
  primary: 'bg-blue-500 hover:bg-blue-700 text-white',
  secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800 border border-gray-400',
};

const sizeClasses = {
  small: 'px-2 py-1 text-sm',
  medium: 'px-4 py-2 text-base',
  large: 'px-6 py-3 text-lg',
};

const selectedVariantClasses = buttonClasses[variant];
const selectedSizeClasses = sizeClasses[size];
---

<button class:list={[selectedVariantClasses, selectedSizeClasses, 'font-bold rounded']}>
  {text}
</button>
"""

"""astro
// src/pages/index.astro
---
import Button from '../components/Button.astro';
---

<Button variant="primary" size="medium" text="Click me!" onClick={() => alert('Clicked!')} />
<Button variant="secondary" size="small" text="Cancel" />
"""

### 1.2 Component Grouping

**Standard:** Group related components into directories based on feature or domain.

**Do This:**

*   Create directories for specific features or sections of the application (e.g., "src/components/blog", "src/components/ui").
*   Include an "index.js" or "index.ts" file in each directory to export all components from that directory.

**Don't Do This:**

*   Dump all components into a single "src/components" directory without any organization.
*   Create deeply nested directory structures that are difficult to navigate.

**Why:** Logical component grouping improves code organization, maintainability, and discoverability.

**Example:**

"""
src/components/
├── blog/
│   ├── ArticleCard.astro
│   ├── ArticleList.astro
│   └── index.ts // Exports ArticleCard and ArticleList
├── ui/
│   ├── Button.astro
│   ├── Input.astro
│   └── index.ts // Exports Button and Input
└── index.ts // Exports all components blog and ui
"""

"""typescript
// src/components/blog/index.ts
export { default as ArticleCard } from './ArticleCard.astro';
export { default as ArticleList } from './ArticleList.astro';
"""

"""typescript
// src/components/index.ts
export * from './blog';
export * from './ui';
"""

### 1.3 Data Fetching Responsibilities

**Standard:** Limit component data fetching responsibilities.

**Do This:**

*   Fetch data in layouts or pages and pass the data as props to components.  This decouples components from specific data sources.
*   Use [Astro.glob](https://docs.astro.build/en/reference/api-reference/#astroglob) or the [Content Collections API](https://docs.astro.build/en/guides/content-collections/) for data fetching within "src/pages" and "src/layouts".
*   When absolutely necessary to fetch data within a component, isolate the data fetching logic into a separate helper function or custom hook.

**Don't Do This:**

*   Perform complex data transformations or business logic within components.
*   Fetch the same data multiple times in different components.

**Why:** Decoupling data fetching improves component reusability and testability.  Centralized data fetching also improves performance by minimizing redundant requests.

**Example:**

"""astro
// src/pages/blog.astro
---
import ArticleCard from '../components/ArticleCard.astro';
import { getCollection } from 'astro:content';

const articles = await getCollection('blog');
---

<main>
  <h1>Blog</h1>
  <ul>
    {articles.map((article) => (
      <li>
        <ArticleCard article={article} />
      </li>
    ))}
  </ul>
</main>
"""

"""astro
// src/components/ArticleCard.astro
---
interface Props {
  article: {
    slug: string;
    data: {
      title: string;
      description: string;
    };
  };
}

const { article } = Astro.props;
---

<a href={"/blog/${article.slug}"}>
  <h2>{article.data.title}</h2>
  <p>{article.data.description}</p>
</a>
"""

## 2. Component Implementation Details

### 2.1 Prop Types

**Standard:** Define explicit prop types for all components using TypeScript.

**Do This:**

*   Create an "interface" named "Props" to define the types of all props.
*   Enforce required props using TypeScript's type system.
*   Provide default prop values for optional props where appropriate.
*   Leverage [Astro.props](https://docs.astro.build/en/reference/api-reference/#astroprops) for type safety

**Don't Do This:**

*   Skip prop type definitions.
*   Use "any" or "unknown" for prop types.
*   Define default prop values using JavaScript's "||" operator, which can lead to unexpected behavior with falsy values.

**Why:** Explicit prop types improve code readability, prevent runtime errors, and improve the developer experience.

**Example:**

"""astro
// src/components/Alert.astro
---
interface Props {
  type: 'success' | 'warning' | 'error' | 'info';
  message: string;
  closable?: boolean;
}

const { type, message, closable = false } = Astro.props;

const alertClasses = {
  success: 'bg-green-100 border-green-400 text-green-700',
  warning: 'bg-yellow-100 border-yellow-400 text-yellow-700',
  error: 'bg-red-100 border-red-400 text-red-700',
  info: 'bg-blue-100 border-blue-400 text-blue-700',
};

const selectedClasses = alertClasses[type];
---

<div class:list={[selectedClasses, 'border rounded p-4 mb-4 flex items-center justify-between']}>
  <span>{message}</span>
  {closable && (
    <button aria-label="Close">
      <svg class="w-4 h-4 fill-current" viewBox="0 0 20 20"><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
    </button>
  )}
</div>
"""

### 2.2 Component Styling

**Standard:** Use a consistent styling approach across all components.

**Do This:**

*   Favor component-scoped styles using Astro's built-in CSS support.
*   Use a CSS preprocessor (e.g., Sass, Less) for complex styling requirements.
*   Use a utility-first CSS framework (e.g., Tailwind CSS) for consistent styling and rapid development.  Install Tailwind using "astro add tailwind".
*   For dynamic styling, use the ":global()" selector sparingly and only when necessary for interacting with third-party libraries or CSS frameworks.
*   Consider using CSS variables for theming.

**Don't Do This:**

*   Use inline styles directly in the HTML templates.
*   Use global styles that can conflict with other components.
*   Mix different styling approaches within the same project.

**Why:** Consistent styling improves code maintainability, reduces visual inconsistencies, and streamlines the development process.

**Example (Tailwind CSS):**

"""astro
// src/components/Card.astro
---
interface Props {
  title: string;
  description: string;
}

const { title, description } = Astro.props;
---

<div class="bg-white rounded-lg shadow-md p-4">
  <h2 class="text-xl font-bold mb-2">{title}</h2>
  <p class="text-gray-700">{description}</p>
</div>

"""

### 2.3 Component State

**Standard:** Minimize component state and use it judiciously.

**Do This:**

*   Prefer stateless functional components whenever possible.
*   When state is necessary, use Astro's client-side directives ("client:load", "client:idle", "client:visible", "client:media") combined with a front-end framework like Solid, React or Vue to manage component state.
*   Consider using a global state management library (e.g., Context API with React, Zustand or Jotai) for complex application state.

**Don't Do This:**

*   Store unnecessary data in component state.
*   Mutate component state directly without using the appropriate setter functions or framework mechanisms.
*   Overuse global state management for simple component-specific state.

**Why:** Minimizing component state improves performance and reduces complexity. Using appropriate state management techniques improves data consistency and prevents unexpected side effects.

**Example (SolidJS with Astro):**

"""astro
---
// src/components/Counter.astro
---
<Counter client:visible />
<script>
  import { render } from 'solid-js/web';
  import { createSignal } from 'solid-js';

  function Counter() {
   const [count, setCount] = createSignal(0);

   return (
    <div>
     <p>Count: {count()}</p>
     <button onClick={() => setCount(count() + 1)}>Increment</button>
    </div>
   );
  }

  render(Counter, document.querySelector('counter'))
</script>

"""

### 2.4 Naming Conventions

**Standard:** Follow consistent naming conventions for components and props.

**Do This:**

*   Use PascalCase for component filenames (e.g., "MyComponent.astro").
*   Use camelCase for prop names (e.g., "myProp", "onClick").
*   Use descriptive and concise names that clearly indicate the component's purpose.
*   Use plural names for components that display a list of items (e.g., "ArticleList").

**Don't Do This:**

*   Use inconsistent naming conventions across the project.
*   Use abbreviations or acronyms that are not widely understood.
*   Use generic names that do not accurately reflect the component's functionality.

**Why:** Consistent naming improves code readability and makes it easier to understand the purpose of components and props.

## 3. Performance Optimization

### 3.1 Component Hydration

**Standard:** Use Astro's partial hydration features judiciously to optimize performance.

**Do This:**

*   Use the "client:" directives ("client:load", "client:idle", "client:visible", "client:media") to control when components are hydrated.
*   Start with "client:idle" or "client:visible" for most interactive components to defer hydration until the browser is idle or the component is visible in the viewport.
*   Use "client:load" only for components that are critical to the initial user experience.
*   Consider using "<astro-island>" for even more granular control over hydration.

**Don't Do This:**

*   Hydrate all components on page load, which can negatively impact performance.
*   Use "client:only" unless you are absolutely sure that the component will only ever be rendered on the client-side.

**Why:** Partial hydration significantly improves page load performance by only hydrating the components that need to be interactive.

**Example:**

"""astro
// src/components/InteractiveComponent.astro
---
// This component will be hydrated when it becomes visible in the viewport.
---
<div client:visible>
  {/* Interactive content here */}
</div>
"""

### 3.2 Image Optimization

**Standard:** Optimize images for performance using Astro's built-in image optimization features or a third-party library.

**Do This:**

*   Use the "<Image />" component from "@astrojs/image" to automatically optimize images.
*   Specify the "width" and "height" props for all images to prevent layout shifts.
*   Use the "format" prop to convert images to modern formats like WebP or AVIF.
*   Use the "quality" prop to control the level of compression.
*   Consider using a CDN (Content Delivery Network) to serve images from a location closer to the user.

**Don't Do This:**

*   Use large, unoptimized images directly in the HTML templates.
*   Skip specifying the "width" and "height" props for images.
*   Serve images from the same server as the application, which can negatively impact performance.

**Why:** Image optimization reduces image file sizes, improves page load times, and enhances the user experience.

**Example:**

"""astro
// src/components/HeroImage.astro
---
import { Image } from '@astrojs/image/components';
import heroImage from '../assets/hero.jpg';
---

<Image src={heroImage} alt="Hero Image" width={1200} height={600} format="webp" quality={80} />
"""

### 3.3 Lazy Loading

**Standard:** Use lazy loading for images and other resources that are not immediately visible in the viewport.

**Do This:**

*   Use the "loading="lazy"" attribute for images to defer loading until they are near the viewport.
*   Consider using a third-party library or custom implementation for lazy loading other types of resources, such as iframes or videos.

**Don't Do This:**

*   Lazy load resources that are above the fold or critical to the initial user experience.

**Why:** Lazy loading improves page load performance by deferring the loading of non-critical resources until they are needed.
**Example:**

"""astro
<img src="/path/to/image.jpg" alt="Description of image" loading="lazy">
"""

## 4. Security Considerations

### 4.1 Input Sanitization

**Standard:** Sanitize user inputs in components to prevent cross-site scripting (XSS) attacks.

**Do This:**

*   Use a sanitization library (e.g., DOMPurify) to sanitize user inputs before rendering them in the HTML templates.
*   Escape HTML entities in user inputs using Astro's built-in templating engine features.

**Don't Do This:**

*   Render user inputs directly in the HTML templates without any sanitization or escaping.

**Why:** Input sanitization prevents malicious code from being injected into the application, which can compromise user data and security.
**Example:**

"""astro
// Example using DOMPurify
---
import DOMPurify from 'dompurify';

interface Props {
  userInput: string;
}
const { userInput } = Astro.props;

// Sanitize the user input
const sanitizedInput = DOMPurify.sanitize(userInput);
---
<p set:html={sanitizedInput}></p>
"""

### 4.2 Avoid Exposing Sensitive Data

**Standard:** Avoid exposing sensitive data in client-side components.

**Do This:**

*   Store sensitive data on the server-side.
*   Use environment variables to store API keys and other sensitive configuration values.  Utilize the "import.meta.env" to access environment variables for the build

**Don't Do This:**

*   Include API keys or other sensitive data directly in client-side components.
*   Expose sensitive data in the HTML source code.

**Why:** Protecting sensitive data prevents unauthorized access and protects user privacy.

**Example:**

"""astro
---
// Access the API key from an environment variable
const apiKey = import.meta.env.PUBLIC_API_KEY;
---

// Use the API key to fetch data from the server
"""

## 5. Testing

### 5.1 Unit Testing

**Standard:** Write unit tests for individual components to ensure they function correctly.

**Do This:**

*   Use a testing framework (e.g., Jest, Mocha) to write unit tests.
*   Test the component's props, state, and rendering behavior.
*   Use mocking to isolate components from external dependencies.

**Don't Do This:**

*   Skip unit tests for complex components.
*   Write unit tests that are tightly coupled to the component's implementation details.

**Why:** Unit tests improve code quality, prevent regressions, and make it easier to refactor code.

### 5.2 Component Integration tests

**Standard:** Write integration tests to ensure components interact correctly in a larger system.

**Do This:**

*   Use testing libraries (e.g., Playwright, Cypress) for end-to-end tests to verify that components render and function correctly in the browser.
*   Verify that data is passed to components in an intended manor.

**Don't Do This:**

*   Neglect to test component collaboration.
*   Write only unit tests, and don't test real life rendering behavior.

**Why:** Unit and Integration testing are essential for ensuring that components work in intended ways.

## 6. Documentation

### 6.1 Component Documentation

**Standard:** Document component usage and functionality clearly.

**Do This:**

*   Include a JSDoc-style comment block at the top of each component file that describes the component's purpose, props, and usage.
*   Use a documentation generator (e.g., Storybook) to create a living style guide for the component library.

**Don't Do This:**

*   Skip documenting component usage and functionality
*   Make hard to maintain documentation. Keep documentation with the components themselves.

**Why:** Documentation improves code understandability, facilitates collaboration, and makes it easier to maintain the component library.

**Example:**

"""astro
/**
 * A reusable button component.
 *
 * @param {string} text - The text to display on the button.
 * @param {'primary' | 'secondary'} variant - The button variant (optional, defaults to 'primary').
 * @param {() => void} onClick - The function to call when the button is clicked (optional).
 */
interface Props {
  text: string;
  variant?: 'primary' | 'secondary';
  onClick?: () => void;
}
"""

These coding standards are a living document and should be updated as new versions of Astro are released and new best practices emerge. By following these standards, development teams can build high-quality, maintainable, and performant Astro applications.
# API Integration Standards for Astro

This document outlines coding standards and best practices for API integration in Astro projects. Following these guidelines will ensure maintainable, performant, and secure interactions with backend services and external APIs.

## 1. Architectural Considerations

### 1.1. Server Endpoints vs. Client-Side Fetching
**Do This:**
*   Use server endpoints (Astro API routes) for sensitive operations, data mutations, and tasks requiring authentication or authorization.
*   Use client-side "fetch" calls only for publicly available data, progressively enhanced experiences, or scenarios where immediate feedback is crucial.

**Don't Do This:**
*   Expose API keys or sensitive logic directly in client-side JavaScript.
*   Overload client-side code with complex data processing or transformations that should be handled server-side.

**Why:** Server endpoints provide a secure environment for handling sensitive data and operations, while client-side fetching can improve user experience for certain types of data retrieval.

**Example (Server Endpoint):**

"""astro
// src/pages/api/submit-form.js
import { APIRoute } from 'astro';

export const post: APIRoute = async ({ request }: APIContext) => {
  if (request.headers.get("Content-Type") === "application/json") {
    const body = await request.json();
    // Process the data securely (e.g., database interaction, email sending)
    console.log("Received form data:", body);

    // Construct a success response
    return new Response(
      JSON.stringify({
        message: 'Form submission successful!',
      }),
      { status: 200 }
    );
  }
  return new Response(null, { status: 400 });
};
"""

**Example (Client-Side Fetch):**

"""astro
---
import { useEffect, useState } from 'astro/hooks';

const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  async function fetchData() {
    try {
      const response = await fetch('https://api.example.com/public-data');
      if (!response.ok) {
        throw new Error("HTTP error! status: ${response.status}");
      }
      const json = await response.json();
      setData(json);
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }

  fetchData();
}, []);
---

{loading && <p>Loading...</p>}
{error && <p>Error: {error.message}</p>}
{data && <pre>{JSON.stringify(data, null, 2)}</pre>}
"""

### 1.2. Data Transformation and Abstraction

**Do This:**
*   Create abstraction layers (e.g., utility functions, services) to encapsulate API interaction logic.
*   Transform API responses into a format suitable for your Astro components, separating presentation from data source.

**Don't Do This:**
*   Directly use API responses within components without transformation or validation.
*   Duplicate API interaction logic throughout your application.

**Why:** Abstraction improves code reusability, testability, and maintainability by decoupling components from specific API implementations.  Transformation ensures data is consistent across all components that need to use it.

**Example (Abstraction Layer):**

"""javascript
// src/lib/api-client.js
const API_BASE_URL = 'https://api.example.com';

export async function getPosts() {
  const response = await fetch("${API_BASE_URL}/posts");
  if (!response.ok) {
    throw new Error("HTTP error! status: ${response.status}");
  }
  const data = await response.json();
  return data.map(post => ({
    id: post.id,
    title: post.title,
    excerpt: post.body.substring(0, 200) + '...', // abstracting to a summary
  }));
}

export async function getPost(id) {
   const response = await fetch("${API_BASE_URL}/posts/${id}");
   if (!response.ok) {
        throw new Error("HTTP error! status: ${response.status}");
   }
   return await response.json();
}
"""

"""astro
---
// src/pages/index.astro
import { getPosts } from '../lib/api-client';

const posts = await getPosts();
---

<ul>
  {posts.map(post => (
    <li>
      <h2>{post.title}</h2>
      <p>{post.excerpt}</p>
    </li>
  ))}
</ul>
"""

## 2. Implementation Standards

### 2.1. Error Handling

**Do This:**
*   Implement robust error handling for all API requests, including network errors, HTTP status codes, and data validation failures.
*   Provide meaningful error messages to users and log errors for debugging purposes.
*   Use "try...catch" blocks and "finally" blocks appropriately to handle asynchronous operations.

**Don't Do This:**
*   Ignore potential errors or rely on default browser error messages.
*   Expose sensitive error information to users.

**Why:** Proper error handling provides a better user experience, simplifies debugging, and prevents application crashes.

**Example:**

"""javascript
// src/lib/api-client.js
export async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      // Log detailed error information for debugging
      console.error("API Error: ${response.status} - ${response.statusText} for URL: ${url}");
      throw new Error("API request failed with status ${response.status}");
    }
    return await response.json();

  } catch (error) {
    // Log the error for server-side monitoring
    console.error("An error occurred while fetching data:", error);
    // Re-throw the error for the calling function to handle
    throw error;
  }
}
"""

"""astro
---
// src/components/MyComponent.astro
import { fetchData } from '../lib/api-client';
import { useState, useEffect } from 'astro/hooks';

const [data, setData] = useState(null);
const [error, setError] = useState(null);
const [loading, setLoading] = useState(true);

useEffect(() => {
  async function loadData() {
    try {
      const result = await fetchData('https://api.example.com/data');
      setData(result);
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }
  loadData();
}, []);
---

{loading && <p>Loading...</p>}
{error && <p>Error: {error.message}</p>}
{data && <pre>{JSON.stringify(data, null, 2)}</pre>}

"""

### 2.2. Data Validation

**Do This:**
*   Validate both request and response data to ensure data integrity.
*   Use schema validation libraries (e.g., Zod, Yup) to define and enforce data structures.
*   Handle validation errors gracefully, providing informative messages to users or logging errors for debugging.

**Don't Do This:**
*   Assume API data is always correct and valid.
*   Perform validation directly in components, mixing validation logic with presentation logic.

**Why:** Data validation prevents unexpected errors, ensures data consistency, safeguards your application from malicious input and greatly helps with debugging.

**Example (Zod Validation):**

"""javascript
// src/lib/schemas.js
import { z } from 'zod';

export const PostSchema = z.object({
  id: z.number(),
  title: z.string().min(5).max(100),
  body: z.string().min(10),
  userId: z.number(),
});

export const CommentSchema = z.object({
    id: z.number(),
    postId: z.number(),
    name: z.string(),
    email: z.string().email(),
    body: z.string()
})

export type Post = z.infer<typeof PostSchema>;
export type Comment = z.infer<typeof CommentSchema>
"""

"""javascript
// src/lib/api-client.js
import { PostSchema } from './schemas';

export async function getPost(id) {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts/${id}");
    if (!response.ok) {
      throw new Error("HTTP error! status: ${response.status}");
    }
    const data = await response.json();

    // Validate the API response against the schema
    const validatedData = PostSchema.parse(data);
    return validatedData;
  } catch (error) {
    console.error("Error fetching and validating post:", error);
    throw error;
  }
}
"""

### 2.3. Authentication and Authorization

**Do This:**
*   Use secure authentication and authorization mechanisms (e.g., OAuth 2.0, JWT) to protect sensitive API endpoints.
*   Store authentication tokens securely (e.g., using HTTP-only cookies, server-side sessions).
*   Implement role-based access control (RBAC) to restrict access to resources based on user roles.

**Don't Do This:**
*   Store passwords or API keys directly in client-side JavaScript.
*   Implement custom authentication schemes without proper security expertise.
*   Expose sensitive information in URLs or request bodies.

**Why:** Authentication and authorization ensure that only authorized users can access protected resources, preventing data breaches and unauthorized actions.

**Example (Server Endpoint with Authentication):**

"""javascript
// src/pages/api/protected.js
import { APIRoute } from 'astro';
import { verifyJwt } from '../../lib/auth'; // Hypothetical JWT verification function

export const get: APIRoute = async ({ request }: APIContext) => {
  const authHeader = request.headers.get('Authorization');

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });
  }
  const token = authHeader.substring(7); // Remove "Bearer "

  try {
    const user = await verifyJwt(token); // Verify JWT
    // Access user information from the verified token
    console.log("Authenticated user:", user);

    // Your protected logic here
    return new Response(JSON.stringify({ message: 'Protected data' }), { status: 200 });

  } catch (error) {
    console.error("JWT verification failed:", error);
    return new Response(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });
  }
};
"""

### 2.4. Rate Limiting and Caching

**Do This:**
*   Implement rate limiting to prevent abuse and protect your API from overload.
*   Use caching strategies (e.g., HTTP caching, server-side caching) to reduce API request frequency and improve performance.

**Don't Do This:**
*   Expose your API without any rate limiting measures.
*   Cache sensitive data without proper security considerations.

**Why:** Rate limiting and caching improve API availability, performance, and security by mitigating abuse, reducing server load, and improving response times.

**Example (Basic Server-Side Caching):**

"""javascript
// src/pages/api/data.js
import { APIRoute } from 'astro';

const cache = new Map();
const CACHE_TTL = 60; // Cache duration in seconds

export const get: APIRoute = async () => {
  const now = Math.floor(Date.now() / 1000); // Current time in seconds

  if (cache.has('data') && cache.get('data').expiry > now) {
    // Return cached data
    console.log("Serving data from cache")
    return new Response(JSON.stringify(cache.get('data').value), { status: 200 });
  }

  try {
    // Simulate fetching data from an external API
    console.log("Fetching from external API")
    const response = await fetch('https://api.example.com/expensive-data');
    if (!response.ok) {
      throw new Error("API request failed with status ${response.status}");
    }
    const data = await response.json();

    // Store data in the cache with an expiry timestamp
    cache.set('data', {
      value: data,
      expiry: now + CACHE_TTL,
    });

    return new Response(JSON.stringify(data), { status: 200 });

  } catch (error) {
    console.error("Error fetching data:", error);
    return new Response(JSON.stringify({ message: 'Failed to fetch data' }), { status: 500 });
  }
};
"""

## 3. Performance Optimization

### 3.1. Minimize Request Size and Latency

**Do This:**
*   Use efficient data formats (e.g., JSON, Protobuf) and compression techniques (e.g., gzip, Brotli).
*   Request only the data you need, using query parameters or specialized API endpoints.
*   Optimize images and other assets to reduce file sizes.
*   Use a CDN (Content Delivery Network) to serve static assets from geographically distributed servers.

**Don't Do This:**
*   Request excessive data that is not used by your application.
*   Use large, unoptimized images or other assets.

**Why:** Reducing request size and latency improves page load times, reduces bandwidth consumption, and provides a better user experience.

### 3.2. Parallelize API Requests

**Do This:**
*   Use "Promise.all" or similar techniques to make concurrent API requests when possible.
*   Avoid making sequential API requests that block other operations.

**Don't Do This:**
*   Overload the server by making too many concurrent requests.  Consider the API provider rate limits and use strategies to avoid going over API quotas.

**Why:** Parallelizing API requests can significantly reduce overall loading time, especially when fetching data from multiple sources.

**Example:**

"""astro
---
import { fetchData } from '../lib/api-client';
import { useState, useEffect } from 'astro/hooks';

const [posts, setPosts] = useState(null);
const [comments, setComments] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  async function loadData() {
    try {
      // Fetch posts and comments concurrently
      const [postsData, commentsData] = await Promise.all([
        fetchData('https://jsonplaceholder.typicode.com/posts'),
        fetchData('https://jsonplaceholder.typicode.com/comments')
      ]);

      setPosts(postsData);
      setComments(commentsData);
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }
  loadData();
}, []);
---

{loading && <p>Loading...</p>}
{error && <p>Error: {error.message}</p>}

<h2>Posts</h2>
{posts && (
  <ul>
    {posts.map(post => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
)}

<h2>Comments</h2>
{comments && (
  <ul>
    {comments.map(comment => (
      <li key={comment.id}>{comment.name}</li>
    ))}
  </ul>
)}
"""
### 3.3. Streaming

**Do This:**
* Leverage streaming API endpoints where response payloads can be transmitted as a continuous stream of data, rather than waiting for the entire response to be constructed before sending it.
* Use libraries like "node-fetch" along with the "ReadableStream" API in JavaScript to handle streaming responses efficiently.
* Display data incrementally as it arrives from the stream to improve the user experience and perceived performance.

**Don't Do This:**
* Buffer the entire stream into memory before processing or displaying the data, negating the benefits of streaming.
* Assume that all API endpoints support streaming; verify that the server supports it and returns data in a streaming format.

**Why:** Streaming reduces time-to-first-byte (TTFB) and allows users to start seeing content immediately.

## 4. Security Best Practices

### 4.1. Input Sanitization and Output Encoding

**Do This:**
*   Sanitize user inputs to prevent cross-site scripting (XSS) and other injection attacks.
*   Encode data properly when rendering it in HTML templates to prevent XSS vulnerabilities.

**Don't Do This:**
*   Trust user inputs without sanitization or validation.
*   Directly render user-provided data in HTML without encoding.

**Why:** Input sanitization and output encoding prevent malicious scripts from executing in the browser, protecting users from XSS attacks.

### 4.2. CORS Configuration

**Do This:**
*   Configure Cross-Origin Resource Sharing (CORS) policies to restrict which domains can access your API.
*   Use a restrictive CORS policy that only allows trusted domains to access your API.

**Don't Do This:**
*   Use a wildcard CORS policy ("Access-Control-Allow-Origin: *"), which allows any domain to access your API.

**Why:** CORS policies prevent unauthorized domains from making requests to your API, protecting it from cross-origin attacks. In Astro, you can configure middleware to enforce CORS.

**Example:**
"""javascript
// src/middleware.js
import { defineMiddleware } from 'astro/middleware';
import { sequence } from 'astro/middleware';

const corsHeaders = {
  "Access-Control-Allow-Origin": "https://your-trusted-domain.com", // Replace with your domain
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
  "Access-Control-Allow-Credentials": "true",
};

const corsMiddleware = defineMiddleware(async (context, next) => {
  if (context.request.method === "OPTIONS") {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }

  const response = await next();
  Object.entries(corsHeaders).forEach(([header, value]) => {
    response.headers.set(header, value);
  });

  return response;
});

const loggingMiddleware = defineMiddleware(async (context, next) => {
  console.log("Request received: ${context.request.method} ${context.request.url}");
  const response = await next();
  console.log("Response sent: ${response.status}");
  return response;
});


export const onRequest = sequence(loggingMiddleware, corsMiddleware);
"""

### 4.3. Secrets Management

**Do This:**
*   Store API keys, passwords, and other secrets securely using environment variables or dedicated secret management services.
*   Avoid committing secrets directly to your code repository.

**Don't Do This:**
*   Store secrets directly in your code or configuration files.
*   Expose secrets in client-side JavaScript.

**Why:** Secure secrets management protects sensitive information from unauthorized access and prevents data breaches. Use ".env" files (and ensure they're in ".gitignore") for local development, and platform-provided environment variables in production.

## 5. API Documentation and Versioning

### 5.1. Documentation

**Do This:**
*   Provide clear and comprehensive documentation for your APIs including endpoints, data types, request/response structures, and authentication methods.
*   Use documentation generators (e.g., Swagger/OpenAPI) to automatically generate documentation from your code.

**Don't Do This:**
*   Deploy APIs without any documentation.
*   Keep documentation outdated or incomplete.

**Why:** Well-maintained documentation allow other developers to effectively use your API.

### 5.2. Versioning

**Do This:**
*   Use API versioning to ensure backwards compatibility when making changes to your APIs.
*   Use semantic versioning (SemVer) to clearly communicate the nature of changes made in each version.

**Don't Do This:**
*   Make breaking changes to APIs without versioning.
*   Fail to communicate deprecated APIs

**Why:** API versioning protects existing integrations from breaking when APIs evolve.

By adhering to these API integration standards, you can build robust, secure, and maintainable Astro applications that effectively interact with external services.
# Security Best Practices Standards for Vercel

This document outlines security best practices for developing and deploying applications on the Vercel platform. Adhering to these standards will reduce your application's risk profile, leading to more reliable and secure deployments.

## 1. Input Validation & Sanitization

### 1.1 Standard

*   **Do This:** Always validate and sanitize user inputs, regardless of origin (e.g., forms, query parameters, cookies, API calls, environment variables). Implement validation on both the client (for immediate feedback) and the server (for ultimate security).
*   **Don't Do This:** Trust user input implicitly.  Never directly use unsanitized user input in database queries, shell commands, or rendered HTML.

### 1.2 Why

*   **Security:** Prevents various injection attacks (SQL injection, XSS, command injection) by ensuring data conforms to expected formats and removing potentially malicious content. It also helps to prevent Denial of Service (DoS) attacks.
*   **Maintainability:** Makes code more robust and predictable, as it handles unexpected input gracefully.
*   **Performance:** Rejecting invalid input early reduces unnecessary processing and resource consumption.

### 1.3 Code Examples

#### 1.3.1 Server-Side Input Validation (Next.js API Route)

"""typescript
// pages/api/submit-form.ts
import { NextApiRequest, NextApiResponse } from 'next';
import validator from 'validator';  // Using a popular validator library

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).end(); // Method Not Allowed
  }

  const { name, email, message } = req.body;

  // Input validation
  if (!name || !validator.isLength(name, { min: 2, max: 100 })) {
    return res.status(400).json({ error: 'Name must be between 2 and 100 characters.' });
  }

  if (!email || !validator.isEmail(email)) {
    return res.status(400).json({ error: 'Invalid email address.' });
  }

  if (!message || !validator.isLength(message, { min: 10, max: 500 })) {
    return res.status(400).json({ error: 'Message must be between 10 and 500 characters.' });
  }

  // Sanitize the input
  const sanitizedName = validator.escape(name);
  const sanitizedEmail = validator.normalizeEmail(email);
  const sanitizedMessage = validator.escape(message);


  // Process the sanitized data (e.g., store in database, send email)
  try {
    //Simulate database interaction to handle the submission
    // normally you would interact with your chosen DB
    console.log({
        name: sanitizedName,
        email: sanitizedEmail,
        message: sanitizedMessage
    })
    res.status(200).json({ success: true });
  } catch (error) {
    console.error('Error processing form submission:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
"""

*   **Explanation:**
    *   The code uses the "validator" library for robust and standardized validation.  Install it with "npm install validator".
    *   It checks data presence and length constraints. Specifically it checks that the "name" is between 2 and 100 characters, email is a valid email, and message is between 10 and 500 characters.
    *   Uses "validator.escape()" to prevent XSS attacks by escaping HTML entities.
    *   Uses "validator.normalizeEmail()" to standardize email addresses.
    *   Error handling is included to gracefully handle unexpected errors.

#### 1.3.2 Client-Side Input Validation (React Component)

"""jsx
// components/ContactForm.tsx
import React, { useState } from 'react';

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

const ContactForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');
  const [errors, setErrors] = useState({name: '', email: '', message: ''});

  const validateForm = () => {
      let isValid = true;
      let newErrors = {name: '', email: '', message: ''};

      if(name.length < 2 || name.length > 100){
          newErrors.name = 'Name must be between 2 and 100 characters.';
          isValid = false;
      }

      if(!EMAIL_REGEX.test(email)){
          newErrors.email = 'Invalid email address.';
          isValid = false;
      }


      if(message.length < 10 || message.length > 500){
          newErrors.message = 'Message must be between 10 and 500 characters.';
          isValid = false;
      }
      setErrors(newErrors);
      return isValid;
  }


  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
        return;
    }


    try {
      const response = await fetch('/api/submit-form', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name, email, message }),
      });

      if (response.ok) {
        alert('Form submitted successfully!');
      } else {
        alert('Form submission failed.');
      }
    } catch (error) {
      console.error('Error submitting form:', error);
      alert('An error occurred while submitting the form.');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="name">Name:</label>
        <input
          type="text"
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
          {errors.name && <p className="error">{errors.name}</p>}
      </div>
      <div>
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
           {errors.email && <p className="error">{errors.email}</p>}
      </div>
      <div>
        <label htmlFor="message">Message:</label>
        <textarea
          id="message"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
          {errors.message && <p className="error">{errors.message}</p>}
      </div>
      <button type="submit">Submit</button>
    </form>
  );
};

export default ContactForm;
"""

*   **Explanation:**
    *   This client-side validation provides immediate feedback to the user.
    * Built in regex variable called "EMAIL_REGEX" used to check structure of email.
    *   The "validateForm" function checks for empty fields and invalid email formats.
    *   Displays error messages to the user if validation fails.
    *   Important: Client-side validation is *not* a substitute for server-side validation.

### 1.4 Anti-Patterns

*   **Blindly trusting environment variables:** While they are generally considered safe, validate environment variables received from external sources or user-provided configurations.  Malicious actors could set unexpected environment variables to exploit vulnerabilities.
*   **Relying solely on client-side validation:** Always perform server-side validation, as client-side validation can be bypassed.
*   **Using insecure functions:** Avoid functions that are known to be vulnerable to injection attacks (e.g., "eval()" in JavaScript, "shell_exec()" in PHP)

## 2. Authentication and Authorization

### 2.1 Standard

*   **Do This:** Implement robust authentication and authorization mechanisms to protect sensitive resources. Use industry-standard protocols like OAuth 2.0 or OpenID Connect for authentication.  Implement role-based access control (RBAC) to authorize users based on their roles and permissions.
*   **Don't Do This:** Store passwords in plain text. Implement your own custom authentication system without proper security expertise. Grant excessive privileges to users.

### 2.2 Why

*   **Security:** Protects sensitive data and functionality from unauthorized access.
*   **Maintainability:** Standardized authentication and authorization systems are easier to manage and audit.
*   **Compliance:** Many regulations require strong authentication and authorization controls.

### 2.3 Code Examples

#### 2.3.1 Authentication with NextAuth.js (Recommended)

"""typescript
// pages/api/auth/[...nextauth].ts
import NextAuth from "next-auth"
import GithubProvider from "next-auth/providers/github"
import { PrismaAdapter } from "@next-auth/prisma-adapter"
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
    }),
  ],
  session: {
    strategy: "jwt"
  },
  jwt: {
    secret: process.env.JWT_SECRET
  },
  callbacks: {
    async session({ session, token, user }) {
      return {
        ...session,
        user: {
          ...session.user,
            id: user.id
        }
      }
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
}
export default NextAuth(authOptions)
"""

*   **Explanation:**
    *   This example uses NextAuth.js, a popular library for adding authentication to Next.js applications.
    *   It uses the GitHub provider for social login. You can configure other providers as well (Google, Facebook, etc.).
    *   It uses "PrismaAdapter" from "@next-auth/prisma-adapter" and "@prisma/client" to persist user data in a database so you will need to install these dependencies. "npm install next-auth @next-auth/prisma-adapter @prisma/client"
    * The code above includes a "jwt" section to add JWT secret.
    *   The "callbacks" section extends the session object with the user ID.  This is critical for authorization logic.
    *   Protect API routes with "getSession" from "next-auth/react".

#### 2.3.2 Protecting API Routes with "getSession"

"""typescript
// pages/api/protected.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { getSession } from 'next-auth/react';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getSession({ req });

  if (!session) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Access the user id from the session
  const userId = session.user.id;

  // Your protected logic here using the user Id extracted from the session.
  res.status(200).json({ message: "Hello ${session.user.name}, your user id is ${userId}" });
}
"""
* The session contains user information if properly authenticated.

#### 2.3.3 Role-Based Access Control (RBAC)

"""typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// Role list
const roles = {
  admin: ['/admin'],
  employee: ['/employee', '/settings'],
  user: ['/settings']
}

// Matching Paths in Regex
const protectedRoutes = ['/admin', '/employee', '/settings'];
const publicRoutes = ['/login', '/register']

export function middleware(req: NextRequest) {
  const session = req.cookies.get('next-auth.session-token');
  const isProtectedRoute = protectedRoutes.some((path) => req.nextUrl.pathname.startsWith(path))

  if (!session && isProtectedRoute) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  // User roles and paths - Database driven

  const role = 'employee'; //Should come from database

  if (roles[role] && roles[role].some((path) => req.nextUrl.pathname.startsWith(path))) {
     return NextResponse.next();
  }
  return NextResponse.redirect(new URL('/', req.url));

}

// See "Matching Paths" below to learn more
export const config = {
  matcher: ['/employee/:path*', '/admin/:path*', '/settings/:path*']
}
"""
*   **Explanation:**
    *   This uses Next.js middleware.
    *   It redirects unauthenticated users to the login page.
    *   Determines user role and compares to allowed routes on the "roles" object.
    *   **Important:** Access user roles from a database or secure store.  *Do not* hardcode roles in middleware.  This demonstration is over-simplified for illustrative purposes.

### 2.4 Anti-Patterns

*   **Storing sensitive information in cookies:** Avoid storing sensitive data (e.g., passwords, API keys) in cookies. If you must store sensitive data in cookies, encrypt it properly and set appropriate flags (e.g., "HttpOnly", "Secure", "SameSite").
*   **Using weak password hashing algorithms:** Always use strong and modern password hashing algorithms like bcrypt, Argon2, or scrypt.
*   **Implementing "remember me" functionality insecurely:**  Use secure tokens with expiration dates and rotate them regularly. Do not simply store usernames and passwords in cookies.
*   **CORS misconfiguration:** Incorrect CORS settings can expose your API to cross-site request forgery attacks.  Carefully configure allowed origins.

## 3. Data Protection

### 3.1 Standard

*   **Do This:** Encrypt sensitive data at rest and in transit. Use HTTPS for all communication. Store encryption keys securely. Implement proper data masking techniques if showing data in UI.
*   **Don't Do This:** Store sensitive data in plain text. Use outdated or weak encryption algorithms. Expose sensitive data in logs or error messages.

### 3.2 Why

*   **Security:** Protects data from unauthorized access and disclosure. Complies with regulations.
*   **Maintainability:** Centralized encryption and key management simplifies security maintenance.
*   **Compliance:** Many regulations (e.g., GDPR, HIPAA) require data protection measures.

### 3.3 Code Examples

#### 3.3.1 Data Encryption with "crypto" Module (Node.js API Route)

"""typescript
// pages/api/encrypt.ts
import { NextApiRequest, NextApiResponse } from 'next';
import crypto from 'crypto';

const algorithm = 'aes-256-cbc'; // Use a strong encryption algorithm
const key = crypto.randomBytes(32); // 32 bytes = 256 bits
const iv = crypto.randomBytes(16);  // 16 bytes = 128 bits

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).end();
  }

  const { data } = req.body;

  if (!data) {
    return res.status(400).json({ error: 'Data is required.' });
  }

  // Encryption
  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);
  let encrypted = cipher.update(data);
  encrypted = Buffer.concat([encrypted, cipher.final()]);

  const encryptedData = {
    iv: iv.toString('hex'),
    encryptedData: encrypted.toString('hex')
  };

  // Decryption (for demonstration purposes within the same endpoint)
  const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), Buffer.from(encryptedData.iv, 'hex'));
  let decrypted = decipher.update(Buffer.from(encryptedData.encryptedData, 'hex'));
  decrypted = Buffer.concat([decrypted, decipher.final()]);

    // Securely store the key and IV. Do *NOT* hardcode or expose them.
    // In a real-world scenario, you'd store these in a secure key vault
  console.log('Encryption Key (keep secret!):', key.toString('hex'));
  console.log('Initialization Vector (keep secret!):', iv.toString('hex'));

  res.status(200).json({ encryptedData, decryptedData: decrypted.toString() });
}
"""

*   **Explanation:**
    *   Uses the "crypto" module for symmetric encryption. Specifically, "aes-256-cbc" is recommended for its strength. Other modern and well-vetted algorithms are also appropriate.
    *   Generates a random encryption key and initialization vector (IV) for each encryption operation.  *Important:* **Never** hardcode encryption keys or IVs.
    *   Demonstrates encryption and decryption.
    *   **Critical:**  In a real application, store the "key" and "iv" securely (e.g., using Vercel's Environment Variables feature with encryption, or a dedicated key management system like HashiCorp Vault). *Never* expose them in your code or logs.

#### 3.3.2  HTTPS Enforcement on Vercel

Vercel automatically provides and manages SSL certificates for your domains.  Enforce HTTPS by:

1.  **Verifying domain configuration:** Ensure your domain is correctly configured in your Vercel project and that the SSL certificate is valid.
2.  **Using "strict-transport-security" header:**  This header tells browsers to only access your site over HTTPS.  Configure this in your "next.config.js" (or similar) file.

#### 3.3.3 next.config.js Configuration

"""javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains; preload',
          },
        ],
      },
    ];
  },
}

module.exports = nextConfig
"""

*   **Explanation:**
    * The configuration above will automatically set the Strict-Transport-Security (HSTS) header for all requests, ensuring that browsers only access your site over HTTPS.

### 3.4 Anti-Patterns

*   **Hardcoding encryption keys:** Never hardcode encryption keys in your code. Store them securely in environment variables or a key management system.
*   **Using ECB mode encryption:** ECB mode is vulnerable to pattern analysis. Use CBC, GCM, or other secure modes.
*   **Logging sensitive data:**  Redact sensitive data from logs and error messages.
*   **Not rotating encryption keys:** Regularly rotate encryption keys to minimize the impact of a potential key compromise.

## 4. Dependency Management

### 4.1 Standard

*   **Do This:** Keep your dependencies up to date with the latest security patches. Use a dependency management tool (e.g., npm, yarn, pnpm) to manage your dependencies and their versions.  Use a tool like Snyk, Dependabot, or Vercel's built-in vulnerability detection to identify and remediate vulnerabilities in your dependencies.
*   **Don't Do This:** Use outdated dependencies with known vulnerabilities. Ignore security alerts from dependency scanning tools. Install dependencies from untrusted sources.

### 4.2 Why

*   **Security:** Prevents exploitation of known vulnerabilities in dependencies.
*   **Maintainability:** Up-to-date dependencies often include bug fixes and performance improvements.
*   **Compliance:** Many regulations require patching known vulnerabilities.

### 4.3 Code Examples

#### 4.3.1 Using Dependabot on GitHub (Recommended)

1.  **Enable Dependabot:**  If your Vercel project is linked to a GitHub repository, enable Dependabot version updates and security updates in your repository settings (Security -> Dependabot).
2.  **Review and merge pull requests:**  Dependabot will automatically create pull requests to update your dependencies. Review these pull requests carefully and merge them to keep your dependencies up to date.

#### 4.3.2 Using Snyk CLI locally

1. **Install Snyk:**
   """bash
   npm install -g snyk
   """

2. **Authenticate Snyk:**
   """bash
   snyk auth
   """
3. **Test your project:**
   """bash
   snyk test
   """
This command scans your project for vulnerabilities and provides remediation advice

#### 4.3.3 Using npm audit

"""bash
npm audit
"""
This command will scan your package-lock.json or package.json file for known vulnerabilities.
* Update vulnerable packages by :
"""bash
npm audit fix
"""

### 4.4 Anti-Patterns

*   **Ignoring Dependabot alerts:** Treat Dependabot alerts seriously and address them promptly.
*   **Disabling dependency scanning:**  Never disable dependency scanning tools.
*   **Installing dependencies globally:** Avoid installing dependencies globally, as this can lead to conflicts and inconsistencies.
*   **Using wildcard version ranges:**  Avoid using overly broad version ranges (e.g., "^1.0.0") in your "package.json" file, as this can introduce breaking changes unexpectedly. Use more specific version ranges (e.g., "~1.0.0" or "1.0.0").
*   **Committing "node_modules":** Under no circumstance commit the "node_modules" directory to version control.

## 5. Error Handling and Logging

### 5.1 Standard

*   **Do This:** Implement proper error handling and logging to capture and analyze errors. Log sufficient information to diagnose and resolve issues, but avoid logging sensitive data. Implement centralized logging to enable efficient analysis.
*   **Don't Do This:** Expose detailed error messages to users. Log sensitive data. Ignore errors.

### 5.2 Why

*   **Security:** Helps identify and respond to security incidents. Prevents attackers from gathering information about your system through error messages.
*   **Maintainability:** Enables quick diagnosis and resolution of issues.
*   **Performance:** Helps identify performance bottlenecks.

### 5.3 Code Examples

#### 5.3.1 Centralized Logging with Vercel Analytics

Vercel Analytics provides built-in error tracking and logging capabilities.  Use it to:

1.  **Track errors in production:**  Vercel Analytics automatically captures errors that occur in your application.
2.  **Analyze error trends:**  Use the Vercel Analytics dashboard to identify common error patterns and prioritize remediation efforts.
3.  **Correlate errors with deploys:**  Vercel Analytics allows you to correlate errors with specific deployments, making it easier to identify the root cause of issues.

#### 5.3.2 Custom Error Logging (Next.js API Route)

"""typescript
// pages/api/example.ts
import { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    // Your code here

    if (Math.random() < 0.5) {
      throw new Error('Simulated error');
    }

    res.status(200).json({ message: 'Success' });
  } catch (error: any) {
    console.error('API Error:', error); // Log the error to console (for Vercel logs)

    // In a production environment, you'd send this error to a central logging service
    // Example: sentry.captureException(error);

    res.status(500).json({ error: 'Internal server error' }); // Generic error message
  }
}
"""

*   **Explanation:**
    *   The code includes a "try...catch" block to handle errors gracefully.
    *   It logs the error to the console using "console.error()". Vercel automatically captures these console logs.
    *   It sends a generic error message to the client to avoid exposing sensitive information.
    *   **Important:**  In a production environment, integrate with a dedicated logging service like Sentry, Datadog, or similar.

#### 5.3.4 Data masking functions for protecting sensitive information

"""typescript
function maskEmail(email: string): string {
  const [username, domain] = email.split('@');
  const maskedUsername = username.slice(0, 2) + '*'.repeat(username.length - 2);
  return "${maskedUsername}@${domain}";
}

function maskPhoneNumber(phoneNumber: string): string {
  return phoneNumber.replace(/(\d{3})\d{3}(\d{4})/, '$1***$2');
}
"""
*  **Explanation**
    * The "maskEmail" function keeps the first two characters of the username and replaces the rest with asterisks.
    * The "maskPhoneNumber" function keeps the first three and last four digits, replacing the middle digits with asterisks.

### 5.4 Anti-Patterns

*   **Exposing stack traces to users:**  Never expose stack traces or other detailed error information to users. This can reveal sensitive information about your system.
*   **Logging passwords or API keys:**  Never log sensitive data like passwords or API keys.
*   **Ignoring unhandled exceptions:**  Always handle unhandled exceptions to prevent your application from crashing. Implement global error handlers to catch unexpected errors.
*   **Over-logging:** Avoid logging excessively, as this can impact performance and storage costs.

## 6. Environment Variables and Secrets Management

### 6.1 Standard

*   **Do This:** Store sensitive information (e.g., API keys, database passwords) in environment variables. Encrypt environment variables if required. Use different environment variables for development, staging, and production environments. Use Vercel's built in secrets management.
*   **Don't Do This:** Hardcode secrets in your code. Commit secrets to version control. Use the same secrets for all environments.

### 6.2 Why

*   **Security:** Protects sensitive data from unauthorized access.
*   **Maintainability:** Simplifies configuration management.
*   **Compliance:** Many regulations require protecting secrets.

### 6.3 Code Examples

#### 6.3.1 Using Vercel Environment Variables

1.  **Set environment variables in the Vercel dashboard:**  Go to your Vercel project settings and add environment variables under the "Environment Variables" section.
2.  **Access environment variables in your code:**  Use "process.env.VARIABLE_NAME" to access environment variables in your code.

"""typescript
// pages/api/data.ts
import { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const apiKey = process.env.API_KEY;

  if (!apiKey) {
    console.error('API_KEY environment variable is not set.');
    return res.status(500).json({ error: 'Internal server error' });
  }

  // Use the API key to fetch data
  // ...
}
"""

#### 6.3.2 Encrypting Environment Variables

Vercel offers the ability to encrypt environment variables within the Vercel dashboard for enhanced security.

### 6.4 Anti-Patterns

*   **Committing ".env" files:** Never commit ".env" files (containing local environment variables) to version control.  Add ".env" to your ".gitignore" file.  Vercel's environment variables are set via the dashboard and do not use ".env" files in production.
*   **Using default secrets:** Avoid using default secrets provided by third-party services. Change them to strong, randomly generated values.
*   **Exposing secrets in client-side code:** Never expose secrets in client-side JavaScript code. Use API routes or serverless functions to access secrets securely.

## 7. Denial-of-Service (DoS) Protection

### 7.1 Standard

*Implement rate limiting to protect your application from being overwhelmed by excessive requests.
*Implement input validation and sanitization to prevent attackers from injecting malicious data that could consume excessive resources.
*Utilize Vercel's built-in caching mechanisms and CDN to reduce the load on your origin servers.
*Implement connection limits to limit the number of concurrent connections from a single IP address or user.*

### 7.2 Why

* Prevents attackers from overwhelming the application with malicious requests. Reduces service unavailabilty. Protects from large scale attacks.

### 7.3 Code Examples
#### 7.3.1 Rate Limiting Implementation
* This can be implemented in Node.js environment using libraries like "express-rate-limit" or "limiter". Rate Limiting can also be implemented at a reverse proxy level.
"""typescript
// middleware.ts
import { NextResponse } from 'next/server'
import { RateLimiter } from 'limiter'
import type { NextRequest } from 'next/server'

const limiter = new RateLimiter({tokensPerInterval: 50, interval: 'minute'})

export async function middleware(req: NextRequest) {
  const remaining = await limiter.removeTokens(1)
  if (remaining < 0) {
    return new NextResponse(
      JSON.stringify({ message: 'Too Many Requests' }),
      {
        status: 429,
        headers: {
          'content-type': 'application/json',
        },
      }
    )
  }

  return NextResponse.next();
}

// See "Matching Paths" below to learn more
export const config = {
  matcher: ['/api/:path*']
}
"""

*   **Explanation:**
    *   This uses Next.js middleware.
    * "tokensPerInterval" is the amount of calls allowed per "interval". In this case 50 per minute.

### 7.4 Anti-Patterns

* Not implementing DDoS protection.
* Not using a DDoS prevention service.
* Ignoring suspicious traffic patterns.

## 8. Security Audits and Penetration Testing

### 8.1 Standard
* Conduct regular security audits of your code and infrastructure to identify potential vulnerabilities.
* Perform penetration testing to simulate real-world attacks and identify weaknesses in your application.
* Engage external security experts to provide independent assessments and recommendations.
* Establish a process for addressing and remediating identified vulnerabilities in a timely manner.

### 8.2 Why
* Proactively identifies and address security vulnerabilities. Provides a high-level of code and application security
* Helps to prevent security incidents and data breaches.

### 8.3 Code Examples
* Tools such as OWASP ZAP or Burp Suite can perform automated testing of web application security. Regular code reviews utilizing the above security standards are also considered part of auditing.

### 8.4 Anti-Patterns

* No use of Security Audits.
* No code reviews.
* Not using penetration testing.

By implementing these security best practices, you can significantly reduce your application's risk profile and protect your data and users. Regularly review and update these standards to keep pace with the evolving threat landscape.
# Core Architecture Standards for Vercel

This document outlines the core architectural standards for developing applications on Vercel. It focuses on fundamental architectural patterns, optimal project structure, and organizational principles to ensure maintainability, performance, and security. These standards are tailored to the Vercel platform and promote the use of modern approaches and patterns.

## 1. Architectural Patterns

Selecting the right architectural pattern is crucial for building scalable and maintainable Vercel applications.

### 1.1. Serverless Functions (API Routes)

Leverage serverless functions for handling API endpoints and backend logic. Vercel's serverless functions allow you to execute code without managing servers, scaling automatically and minimizing operational overhead.

**Do This:**

*   Use serverless functions for handling API requests, database interactions, and background tasks.

**Don't Do This:**

*   Avoid running long-running processes directly within serverless functions.  Use queues or background jobs for computationally intensive tasks.

**Why:** Serverless functions ensure scalability, reduce costs by only charging for actual usage, and simplify deployment management.

**Code Example (Next.js API Route):**

"""javascript
// pages/api/hello.js
export default async function handler(req, res) {
  if (req.method === 'GET') {
    res.status(200).json({ message: 'Hello from Vercel!' });
  } else {
    res.status(405).json({ message: 'Method Not Allowed' });
  }
}
"""

**Anti-Pattern:** Placing heavy computation directly inside a serverless function without considering timeouts or performance implications.

### 1.2. Jamstack Architecture

Jamstack (JavaScript, APIs, and Markup) is an architectural approach that emphasizes pre-rendering, decoupling, and leveraging edge caching.

**Do This:**

*   Pre-render as much content as possible during build time using Static Site Generation (SSG) or Incremental Static Regeneration (ISR).
*   Use a Content Delivery Network (CDN) for serving static assets. Vercel's Edge Network is ideal for this.
*   Decouple the frontend from the backend using APIs, allowing for greater flexibility and scalability.

**Don't Do This:**

*   Rely on server-side rendering (SSR) for content that can be pre-rendered.
*   Bypass the CDN and directly serve static assets from the origin server.

**Why:** Jamstack enhances performance, improves security by minimizing the attack surface, and simplifies deployments.

**Code Example (Next.js SSG):**

"""javascript
// pages/index.js
export async function getStaticProps() {
  // Fetch data from an API or CMS
  const data = await fetchData();

  return {
    props: {
      data,
    },
  };
}

export default function Home({ data }) {
  return (
    
      <h1>{data.title}</h1>
      <p>{data.content}</p>
    
  );
}
"""

**Code Example (Next.js ISR):**

"""javascript
// pages/blog/[slug].js
export async function getStaticPaths() {
  // Get all possible paths based on external data
  const posts = await fetchPosts();
  const paths = posts.map((post) => ({
    params: { slug: post.slug },
  }));

  return {
    paths,
    fallback: 'blocking', // or true for incremental generation
  };
}

export async function getStaticProps({ params }) {
  // Fetch data for the specific slug
  const post = await fetchPost(params.slug);

  return {
    props: {
      post,
    },
    revalidate: 60, // Revalidate every 60 seconds
  };
}

export default function Post({ post }) {
  return (
    
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    
  );
}
"""

**Anti-Pattern:** Using SSR for content that is rarely updated, leading to unnecessary server load and slower page loads.

### 1.3. Microservices (Polyrepo vs. Monorepo using Vercel Projects)

When the application grows in complexity, consider a microservices architecture which Vercel can support effectively through multiple "Vercel Projects" pointing at different repositories.

**Do This:**

*   If choosing microservices, design services with clear boundaries and single responsibilities.
*   Consider the trade-offs between a polyrepo (multiple repositories, one per service) and a monorepo (single repository for all services) approach.  Vercel Projects work equally well for either, but the organization and deployment strategies differ.
*   Use a service mesh or API gateway for managing communication between services.
*   Set up separate Vercel projects for each microservice to manage deployments and scaling independently.

**Don't Do This:**

*   Create overly granular microservices that introduce unnecessary complexity.
*   Share database schemas or business logic between services without careful consideration.

**Why:** Microservices improve scalability, fault isolation, and team autonomy.  Vercel's project structure allows for easy management of multiple services.

**Polyrepo Example:**

*   "repo-auth-service" Vercel Project -> connects to auth-service repo
*   "repo-user-service" Vercel Project -> connects to user-service repo
*   "repo-product-service" Vercel Project -> connects to product-service repo

**Monorepo Example:**

*   "main-repo" Vercel Project (configure the settings to only deploy changed directories)

**Anti-Pattern:** Creating a "distributed monolith" where services are tightly coupled and dependent on each other.

### 1.4 Edge Functions

Utilize Vercel Edge Functions for tasks that require low latency and high performance, like personalization and geolocation.

**Do This:**

*   Implement Edge Functions for tasks like A/B testing, authentication, and request rewriting, leveraging geographical proximity to the user.
*   Cache responses at the edge to reduce latency and improve performance.

**Don't Do This:**

*   Execute complex business logic or database operations within Edge Functions due to limitations on execution time and resources.
*   Overuse Edge Functions for tasks that can be efficiently handled by serverless functions.

**Why:** Edge Functions provide low latency, improved performance, and scalability at the edge of the network.

**Code Example (Edge Function):**

"""typescript
// middleware.ts (Vercel's Edge Middleware)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const country = request.geo?.country || 'US'

  if (country === 'DE') {
    return NextResponse.rewrite(new URL('/de/homepage', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/',
}
"""

**Anti-Pattern:** Using Edge Functions for operations that require significant computation or database access results in slow performance and potential timeouts.

## 2. Project Structure and Organization

A well-defined project structure is essential for maintainability and collaboration.

### 2.1. Monorepo vs. Polyrepo

Choose a project structure that aligns with your organization's size, complexity, and development workflow.

**Do This:**

*   For small to medium-sized projects, start with a monorepo for simplicity using tools like Turborepo or Nx.
*   For large, complex applications with multiple teams, consider a polyrepo structure for greater autonomy and scalability.

**Don't Do This:**

*   Switch between monorepo and polyrepo without carefully considering the implications on tooling, deployment, and collaboration.
*   Create a deeply nested directory structure within the repository.

**Why:** A well-organized project structure improves code discoverability, simplifies dependency management, and promotes code reuse.

**Monorepo Example (using Turborepo):**

"""
my-monorepo/
  apps/
    web/           # Next.js frontend
    docs/          # Documentation website
  packages/
    ui/            # UI component library
    utils/         # Utility functions
  turbo.json       # Turborepo configuration
  package.json     # Root package.json
"""

**Anti-Pattern:**  A disorganized repository structure that makes it difficult to find and understand code.

### 2.2. Directory Structure for Next.js Projects

Organize Next.js projects using a structure that promotes separation of concerns and maintainability.

**Do This:**

*   Use the "pages" directory for defining routes and API endpoints.
*   Create a "components" directory for reusable UI components.
*   Store utility functions and helper modules in a "utils" or "lib" directory.
*   Use an "assets" directory for static assets like images and fonts.
*   Create a "styles" directory for CSS modules, global stylesheets, and theme definitions.

**Don't Do This:**

*   Place all code within the "pages" directory, leading to a monolithic structure.
*   Mix components, utilities, and styles in the same directory.

**Why:** A standardized directory structure enables clear separation of concerns, simplifies navigation, and promotes code reuse.

**Code Example (Directory Structure):**

"""
my-next-app/
  pages/
    api/
      hello.js          # API endpoint
    index.js          # Home page
    about.js          # About page
  components/
    Button.js         # Reusable button component
    Header.js         # Header component
  utils/
    api.js            # API client functions
    formatDate.js     # Date formatting utility
  assets/
    logo.png          # Logo image
  styles/
    globals.css       # Global styles
    Button.module.css # CSS Modules for Button component
"""

**Anti-Pattern:**  A flat directory structure that mixes different types of files, making it difficult and time-consuming to find specific code.

### 2.3. Component-Based Architecture

Design the application using reusable and composable components.

**Do This:**

*   Break down the UI into smaller components with single responsibilities.
*   Use prop types or TypeScript for defining component interfaces.
*   Create a component library for reusable UI elements.

**Don't Do This:**

*   Create large, monolithic components that are difficult to maintain and reuse.
*   Duplicate code across multiple components.

**Why:** A component-based architecture promotes code reuse, simplifies maintenance, and improves testability.

**Code Example (React Component):**

"""jsx
// components/Button.js
import React from 'react';
import styles from './Button.module.css';
import PropTypes from 'prop-types';

function Button({ children, onClick, className }) {
  return (
    
      {children}
    
  );
}

Button.propTypes = {
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func,
  className: PropTypes.string,
};

export default Button;
"""

**Anti-Pattern:**  Duplicating code across multiple components instead of creating a reusable component.

## 3. Code Organization Principles

### 3.1. Separation of Concerns

Divide the code into distinct sections, each addressing a separate concern.

**Do This:**

*   Separate concerns for UI rendering, data fetching, business logic, and data storage.
*   Use custom hooks to encapsulate reusable logic.

**Don't Do This:**

*   Mix UI rendering, data fetching, and business logic in the same component.

**Why:** Separation of concerns improves code maintainability, testability, and readability.

**Code Example (Custom Hook):**

"""javascript
// hooks/useFetch.js
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
      } catch (e) {
        setError(e);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [url]);

  return { data, loading, error };
}

export default useFetch;

// pages/index.js
import useFetch from '../hooks/useFetch';

function Home() {
  const { data, loading, error } = useFetch('/api/data');

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    
      <h1>Data from API</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    
  );
}

export default Home;
"""

**Anti-Pattern:**  A component that performs UI rendering, data fetching, and data manipulation, making it difficult to understand and maintain.

### 3.2. Single Responsibility Principle (SRP)

Ensure that each class, function, or component has only one reason to change.

**Do This:**

*   Design functions and components that perform a single, well-defined task.
*   Avoid creating functions or classes that are responsible for multiple unrelated tasks.

**Don't Do This:**

*  Create a utility function that can format dates, validate emails, and trim strings, violating SRP.

**Why:** SRP improves code clarity, testability, and reduces the risk of introducing bugs when modifying code.

**Code Example (SRP Compliant Function):**

"""javascript
// utils/formatDate.js
function formatDate(date) {
  return new Date(date).toLocaleDateString();
}

export default formatDate;

// utils/validateEmail.js
function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

export default validateEmail;


"""

**Anti-Pattern:** A lengthy function that could be broken down into smaller, more manageable functions, violating SRP.

### 3.3. Convention over Configuration

Adopt a common set of conventions for naming, directory structure, and coding style. Vercel / Next.js encourages this, but you can codify more specific rules.

**Do This:**

*   Use consistent naming conventions for variables, functions, and components.
*   Follow a standardized directory structure for organizing project files.
*   Use a configuration management system to centralize and manage application settings.

**Don't Do This:**

*  Inconsistent naming conventions that make it difficult to understand the purpose of a variable or function.

**Why:** Convention over configuration reduces cognitive load, improves code consistency, and simplifies onboarding for new developers.

**Technology-Specific Details:**

*   Leverage Vercel's environment variables for configuring different deployment environments.
*   Use Vercel's analytics and logging to monitor application performance and identify potential issues.
*   Use Next.js's built-in features for routing, API endpoints, and data fetching.

By adhering to these core architectural standards, you can build robust, scalable, and maintainable applications on Vercel. These standards are intended to provide a foundation for creating high-quality code that is easy to understand, test, and extend.
# Component Design Standards for Vercel

This document outlines the component design standards for Vercel projects. These standards are designed to promote reusable, maintainable, and performant code, taking advantage of Vercel's features and ecosystem. The goal is to provide clear guidelines that enhance code quality, team collaboration, and overall project success.

## 1. Component Architecture and Organization

### Standard 1.1: Atomic Design Principles

**Do This:** Structure components based on Atomic Design principles: Atoms, Molecules, Organisms, Templates, and Pages.

**Don't Do This:** Create monolithic components that handle multiple responsibilities.

**Why:** Atomic Design promotes modularity, reusability, and testability.

**Example:**
"""jsx
// Atoms
// Button.jsx
const Button = ({ children, onClick }) => (
  <button onClick={onClick}>{children}</button>
);

export default Button;


// Molecules
// SearchBar.jsx
import Button from './Button';

const SearchBar = ({ onSearch }) => (
  <div>
    <input type="text" placeholder="Search..." />
    <Button onClick={onSearch}>Search</Button>
  </div>
);

export default SearchBar;

// Organisms
// Header.jsx
import SearchBar from './SearchBar';

const Header = () => (
  <header>
    <h1>My App</h1>
    <SearchBar onSearch={() => console.log('Searching...')} />
  </header>
);

export default Header;

// Template
// BasicLayout.jsx

import Header from './Header';
import Footer from './Footer'

const BasicLayout = ({ children }) => (
  <>
    <Header />
      <main>{children}</main>
    <Footer />
  </>
);

export default BasicLayout;


// Pages
// HomePage.jsx

import BasicLayout from './BasicLayout';

const HomePage = () => (
  <BasicLayout>
    {/* Page content here */}
    <h1>Welcome to the Home Page</h1>
  </BasicLayout>
);

export default HomePage;

"""

### Standard 1.2: Component Directory Structure

**Do This:** Organize components in a clear, hierarchical directory structure.  A common pattern is "components/{ComponentName}/{ComponentName}.jsx", "components/{ComponentName}/index.jsx", potentially with accompanying test files.

**Don't Do This:** Scatter components randomly throughout the project.

**Why:** A well-defined directory structure improves navigation and maintainability.

**Example:**

"""
src/
└── components/
    ├── Button/
    │   ├── Button.jsx
    │   └── Button.module.css (Optional, for CSS Modules)
    ├── SearchBar/
    │   ├── SearchBar.jsx
    │   └── SearchBar.module.css
    ├── Header/
    │   ├── Header.jsx
    │   └── Header.module.css
    └── index.js (optional: exports all components)
"""

"src/components/index.js" (Optional):
"""javascript
export { default as Button } from './Button/Button';
export { default as SearchBar } from './SearchBar/SearchBar';
export { default as Header } from './Header/Header';
"""

### Standard 1.3: Container vs. Presentational Components

**Do This:** Separate components into "container" components (data fetching, state management) and "presentational" components (UI rendering).

**Don't Do This:** Mix data fetching and UI rendering logic within a single component.

**Why:** Separation of concerns makes components more reusable and testable. In the context of Vercel and Next.js, this can improve performance by controlling where data fetching happens (server vs client).

**Example:**

"""jsx
// Container Component (fetches data) - e.g., pages/blog/[id].js or a dedicated component
// Client-side rendering with useEffect example
import { useState, useEffect } from 'react';
import BlogPost from '../../components/BlogPost/BlogPost'; // Presentational Component

const BlogPostContainer = ({ id }) => {
  const [post, setPost] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchPost = async () => {
      // Use relative URL for API Route
        const res = await fetch("/api/blog/${id}");

        if (!res.ok) {
          throw new Error("Failed to fetch post with id ${id}");

        }
         const data = await res.json();
        setPost(data);


      setLoading(false);
    };


    fetchPost();
  }, [id]);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (!post) {
    return <p>Post not found.</p>;
  }

  return <BlogPost post={post} />;
};

// Server-side rendering approach using getStaticProps
export async function getStaticProps({ params }) {
  const { id } = params;

    // Direct API call to your backend or CMS - example
  const res = await fetch("https://your-cms.com/api/blog/${id}");
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
}

export async function getStaticPaths() {
  // Fetch a list of all post IDs
    // Direct API call to your backend or CMS - example
  const res = await fetch("https://your-cms.com/api/blog"); // fetches all posts
  const posts = await res.json();
  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return {
    paths,
    fallback: false, // or 'blocking'
  };
}


export default BlogPostContainer;


// Presentational Component (renders UI) - BlogPost.jsx
const BlogPost = ({ post }) => (
  <div>
    <h2>{post.title}</h2>
    <p>{post.content}</p>
  </div>
);

export default BlogPost;
"""

## 2. Component Implementation

### Standard 2.1: Functional Components with Hooks

**Do This:** Use functional components with React Hooks for state management and side effects.

**Don't Do This:** Rely heavily on class-based components, especially for new code.

**Why:** Functional components with Hooks are more concise, readable, and easier to test.

**Example:**

"""jsx
import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default Counter;
"""

### Standard 2.2: Prop Types and TypeScript

**Do This:** Use prop types or TypeScript to define the expected types of component props.  TypeScript is strongly preferred.

**Don't Do This:**  Define components without specifying the types of props.

**Why:** Type checking helps catch errors early and improves code maintainability. In a Vercel & Next.js context, TypeScript helps ensure API responses are correctly handled in your components, avoiding runtime errors.

**Example (TypeScript):**

"""tsx
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean; // Optional prop
}

const Button: React.FC<ButtonProps> = ({ label, onClick, disabled }) => (
  <button onClick={onClick} disabled={disabled}>
    {label}
  </button>
);

export default Button;
"""

### Standard 2.3: Controlled vs. Uncontrolled Components

**Do This:** Choose between controlled and uncontrolled components based on your needs.  Generally, prefer controlled components when you need to directly manipulate the value, and uncontrolled components when you just need to get the value on submit.

**Don't Do This:**  Use uncontrolled components without a clear understanding of their implications for state management.

**Why:**  Understanding controlled and uncontrolled components is crucial for managing form state effectively.

**Example (Controlled):**

"""jsx
import { useState } from 'react';

const Input = () => {
  const [value, setValue] = useState('');

  return (
    <input
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
};

export default Input;
"""

**Example (Uncontrolled):**

"""jsx
const Input = () => {
  const handleSubmit = (e) => {
    e.preventDefault();
    const value = e.target.myInput.value;
    console.log(value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="myInput" />
      <button type="submit">Submit</button>
    </form>
  );
};

export default Input;
"""

### Standard 2.4: Handling Events

**Do This:** Use arrow functions or "bind" to ensure the correct "this" context in event handlers.

**Don't Do This:**  Use inline functions in JSX without considering performance implications (re-renders).  Memoize functions when necessary.

**Why:**  Correctly binding event handlers prevents unexpected behavior.  Memoization optimizes performance by preventing unnecessary re-renders.

**Example:**

"""jsx
import { useState, useCallback } from 'react';

const MyComponent = () => {
  const [count, setCount] = useState(0);

  // Memoize the increment function
  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default MyComponent;
"""

### Standard 2.5:  Key Property for Lists

**Do This:** When rendering lists of elements, provide a unique "key" prop to each element.

**Don't Do This:**  Use array indices as keys unless the list is static and never changes.

**Why:**  Keys help React efficiently update the DOM when list items are added, removed, or reordered.  Using indices as keys can lead to unexpected behavior and performance problems.

**Example:**
"""jsx
const MyList = ({ items }) => (
  <ul>
    {items.map((item) => (
      <li key={item.id}>{item.name}</li>
    ))}
  </ul>
);

export default MyList;
"""

## 3. Styling and CSS

### Standard 3.1: CSS Modules or Styled Components

**Do This:**  Use CSS Modules or Styled Components for styling components.  TailwindCSS is also acceptable but should be used via "tailwind.config.js" and the "@apply" directive for component-specific styling (discouraging inline "className" strings) to maintain consistency.

**Don't Do This:**  Use global CSS styles that can conflict with other components.

**Why:**  CSS Modules and Styled Components provide scoping and prevent naming collisions, enhancing maintainability.  Tailwind's "@apply" promotes reuse and reduces redundant configurations.

**Example (CSS Modules):**

"""jsx
// Button.module.css
.button {
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
}

// Button.jsx
import styles from './Button.module.css';

const Button = ({ children, onClick }) => (
  <button className={styles.button} onClick={onClick}>
    {children}
  </button>
);

export default Button;
"""

**Example (Styled Components):**

"""jsx
import styled from 'styled-components';

const StyledButton = styled.button"
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
";

const Button = ({ children, onClick }) => (
  <StyledButton onClick={onClick}>
    {children}
  </StyledButton>
);

export default Button;
"""

**Example (TailwindCSS with "@apply"):**

"""css
/* Button.css  (or Button.module.css) */
.button {
  @apply bg-blue-500 text-white py-2 px-4 rounded;
}

/* Button.jsx */
import './Button.css'; // or import styles from './Button.module.css';

const Button = ({ children, onClick }) => (
  <button className="button" onClick={onClick}>
    {children}
  </button>
);

export default Button;
"""

### Standard 3.2: Responsive Design

**Do This:** Implement responsive design using media queries or CSS-in-JS libraries like Styled Components that support media queries. Libraries like "react-responsive" or "useMediaQuery" hook can also be utilized.

**Don't Do This:**  Create layouts that are only suitable for a single screen size.

**Why:** Responsive design ensures a consistent user experience across different devices.

**Example (Styled Components with Media Queries):**

"""jsx
import styled from 'styled-components';

const ResponsiveDiv = styled.div"
  width: 100%;

  @media (min-width: 768px) {
    width: 50%;
  }

  @media (min-width: 1200px) {
    width: 33.33%;
  }
";

const MyComponent = () => (
  <ResponsiveDiv>
    This div will adjust its width based on screen size.
  </ResponsiveDiv>
);

export default MyComponent;
"""

### Standard 3.3: Theming (for visual consistency)

**Do This:** Implement theming using React Context or a dedicated theming library like "styled-components".  CSS variables (custom properties) are a good alternative if broad browser support is required.

**Don't Do This:**  Hardcode colors, fonts, and other style values directly in components.

**Why:**  Theming allows for easy customization and maintains a consistent look and feel across the application.

**Example (React Context):**

"""jsx
// ThemeContext.jsx
import { createContext, useState } from 'react';

export const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};


// Button.jsx
import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

const Button = ({ children, onClick }) => {
  const { theme } = useContext(ThemeContext);

  const buttonStyle = {
    backgroundColor: theme === 'light' ? 'blue' : 'darkblue',
    color: 'white',
    padding: '10px 20px',
    border: 'none',
    cursor: 'pointer',
  };

  return (
    <button style={buttonStyle} onClick={onClick}>
      {children}
    </button>
  );
};

export default Button;

// App.jsx
import { ThemeProvider } from './ThemeContext';
import Button from './Button';

const App = () => (
  <ThemeProvider>
    <Button onClick={() => console.log('Clicked!')}>Click Me</Button>
  </ThemeProvider>
);

export default App;
"""

## 4. Data Fetching and API Communication (Vercel Specific)

### Standard 4.1: "getStaticProps" and "getServerSideProps"

**Do This:** Use "getStaticProps" for data that is known at build time (e.g., content from a CMS). Use "getServerSideProps" for data that needs to be fetched on every request (e.g., user-specific data). Utilize Incremental Static Regeneration (ISR) with "revalidate" to balance static performance with near real-time updates.

**Don't Do This:**  Fetch data on the client-side if it can be fetched during build or server-side rendering, whenever SEO is a concern. This includes avoiding the "useEffect" hook for initial data population when possible.

**Why:**  Using "getStaticProps" and "getServerSideProps" optimizes performance and SEO in Vercel. ISR allows you to update static pages efficiently while maintaining optimal performance.

**Example ("getStaticProps" with ISR):**

"""jsx
export async function getStaticProps() {
  // Fetch data from an API
  const res = await fetch('https://.../posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 60, // Regenerate the page every 60 seconds
  };
}

const PostList = ({ posts }) => (
  <ul>
    {posts.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);

export default PostList;
"""

**Example ("getServerSideProps"):**

"""jsx
export async function getServerSideProps(context) {
  // Fetch data on every request
  const res = await fetch('https://.../user-data');
  const userData = await res.json();

  return {
    props: {
      userData,
    },
  };
}

const UserProfile = ({ userData }) => (
  <div>
    <h1>{userData.name}</h1>
    <p>{userData.email}</p>
  </div>
);

export default UserProfile;
"""

### Standard 4.2: Vercel Edge Functions

**Do This:** Utilize Vercel Edge Functions for tasks that require low latency and proximity to users (e.g., A/B testing, personalization). Place logic closer to the user when possible.

**Don't Do This:**  Use Edge Functions for long-running tasks or tasks that require access to a database that is not optimized for edge deployment.

**Why:** Edge Functions provide low-latency execution and can improve the performance of geographically distributed applications.

**Example:**
"""javascript
// vercel.json
{
  "routes": [
    {
      "src": "/api/hello",
      "dest": "/api/hello.js"
    }
  ]
}

// api/hello.js (Edge Function)
export const config = {
  runtime: 'edge',
};

export default async function handler(request, context) {
  return new Response("Hello, from the edge!", {
    status: 200,
    headers: {
      'content-type': 'text/plain',
    },
  });
}
"""

### Standard 4.3: API Routes

**Do This:**  Use Next.js API routes for backend logic that needs to run server-side within your Vercel application. Use them for form submissions, server-side data processing, or interacting with databases. Ensure proper error handling and validation.

**Don't Do This:**  Implement complex backend logic directly in client-side components. Handle API requests and data transformations exclusively client-side when it creates security risks client side.

**Why:** API routes provide a secure and scalable way to handle backend logic in your Vercel application.

**Example:**
"""javascript
// pages/api/submit.js
export default async function handler(req, res) {
  if (req.method === 'POST') {
    const data = req.body;

    // Validate data
    if (!data.name || !data.email) {
      return res.status(400).json({ error: 'Name and email are required' });
    }

    // Process data (e.g., save to database)
    try {
      // Example: Simulate saving to a database
      console.log('Data received:', data);
      res.status(200).json({ message: 'Form submitted successfully' });
    } catch (error) {
      console.error('Error processing data:', error);
      res.status(500).json({ error: 'Failed to process data' });
    }
  } else {
    res.status(405).json({ error: 'Method not allowed' });
  }
}
"""

### Standard 4.4: Error Handling

**Do THIS:** Implement robust error handling in API routes and data fetching logic.  Return meaningful error messages to the client. Use centralized error logging (e.g. Sentry) to track errors in production.

**Don't Do THIS:**  Expose sensitive information in error messages. Fail silently without logging errors.

**Why:**  Proper error handling helps prevent application crashes and provides valuable insights into potential issues.

**Example:**

"""javascript
// pages/api/data.js
import { captureException } from '@sentry/nextjs'; // Assuming you are using Sentry

export default async function handler(req, res) {
  try {
    // Simulate an error
    throw new Error('Failed to fetch data');

    const data = await fetchData();
    res.status(200).json(data);
  } catch (error) {
    console.error('Error fetching data:', error);
    captureException(error); // Log error to Sentry

    res.status(500).json({ error: 'Failed to fetch data.  Please try again later.' }); // Generic error message to client.
  }
}
"""

## 5. Component Testing

### Standard 5.1: Unit Tests

**Do This:**  Write unit tests for individual components to ensure they function as expected. Use testing frameworks like Jest and React Testing Library.

**Don't Do This:**  Skip unit tests for components, especially complex ones. Rely solely on end-to-end tests.

**Why:**  Unit tests provide fast feedback and help catch bugs early in the development process.

**Example:**

"""jsx
// Button.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

test('renders a button with the correct label', () => {
  render(<Button label="Click Me" />);
  const buttonElement = screen.getByText('Click Me');
  expect(buttonElement).toBeInTheDocument();
});

test('calls the onClick handler when clicked', () => {
  const onClick = jest.fn();
  render(<Button label="Click Me" onClick={onClick} />);
  const buttonElement = screen.getByText('Click Me');
  fireEvent.click(buttonElement);
  expect(onClick).toHaveBeenCalledTimes(1);
});
"""

### Standard 5.2: Integration Tests

**Do This:**  Write integration tests to ensure that components work together correctly.

**Don't Do This:**  Test components in isolation without verifying their interactions with other components.

**Why:** Integration tests verify that the different parts of the application work together as expected.

### Standard 5.3: End-to-End Tests

**Do This:** Use end-to-end (E2E) testing frameworks like Cypress or Playwright to test the entire application flow, simulating real user interactions. Vercel integrates seamlessly with Cypress for automated testing during deployment.

**Don't Do This:** Rely solely on manual testing. Deploy code without any automated E2E testing.

**Why:**  E2E tests verify that the application works correctly from the user's perspective and help catch integration issues.

## 6. Component Documentation

### Standard 6.1: JSDoc or TypeScript Documentation

**Do This:**  Use JSDoc comments or TypeScript to document components, their props, and their behavior.

**Don't Do This:**  Leave components undocumented. Write insufficient documentation that does not explain how a component should be used.

**Why:**  Documentation makes components easier to understand and use by other developers.

**Example (JSDoc):**

"""jsx
/**
 * A reusable button component.
 *
 * @param {string} label - The text to display on the button.
 * @param {function} onClick - The function to call when the button is clicked.
 * @param {boolean} [disabled=false] - Whether the button is disabled.
 */
const Button = ({ label, onClick, disabled }) => (
  <button onClick={onClick} disabled={disabled}>
    {label}
  </button>
);

export default Button;
"""

**Example (TypeScript):**

"""tsx
interface ButtonProps {
  /** The text to display on the button. */
  label: string;
  /** The function to call when the button is clicked. */
  onClick: () => void;
  /** Whether the button is disabled. Defaults to false. */
  disabled?: boolean;
}

/** A reusable button component. */
const Button: React.FC<ButtonProps> = ({ label, onClick, disabled }) => (
  <button onClick={onClick} disabled={disabled}>
    {label}
  </button>
);

export default Button;
"""

### Standard 6.2: Component Storybook

**Do This:**  Use Storybook to create a component library with interactive examples of each component.

**Don't Do This:**  Develop components in isolation without a visual representation of their usage.

**Why:**  Storybook provides a visual way to browse and test components, making it easier to maintain a consistent UI and ensure components are reusable. Also, it supports automated visual regression tests.

## 7. Accessibility (A11Y)

### Standard 7.1: ARIA Attributes

**Do This:** Use ARIA attributes to provide semantic information to assistive technologies, such as screen readers.  Verify accessibility using tools like Axe.

**Don't Do This:**  Ignore accessibility considerations. Create components that are not usable by people with disabilities.

**Why:**  ARIA attributes make web applications more accessible to users with disabilities.

**Example:**

"""jsx
const AccessibleButton = ({ children, onClick, ariaLabel }) => (
  // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
  <div
    role="button"
    aria-label={ariaLabel}
    tabIndex={0}
    onClick={onClick}
  >
    {children}
  </div>
);

export default AccessibleButton;
"""

### Standard 7.2: Semantic HTML

**Do This:** Use semantic HTML elements (e.g., "<article>", "<nav>", "<aside>", "<header>", "<footer>") to structure content. Use proper heading hierarchy ("<h1>" through "<h6>").

**Don't Do This:** Use "<div>" and "<span>" elements for all content.

**Why:** Semantic HTML improves accessibility and SEO by providing a clear structure to the content.

### Standard 7.3: Keyboard Navigation

**Do This:** Ensure that all interactive elements are accessible via keyboard navigation. Use the "tabIndex" attribute to control the focus order.

**Don't Do This:**  Create components that can only be used with a mouse.

## 8. Performance Optimization (Vercel Specific)

### Standard 8.1: Code Splitting

**Do This:**  Use dynamic imports to split code into smaller chunks that are loaded on demand.

**Don't Do This:**  Load all code upfront, especially for large applications.

**Why:**  Code splitting improves initial load time and reduces the amount of JavaScript that needs to be parsed and executed.

**Example:**

"""jsx
import dynamic from 'next/dynamic';

const MyComponent = dynamic(() => import('./MyComponent'), {
  loading: () => <p>Loading...</p>,

  // Optional: SSR False for client-side rendering only.
  ssr: false
});

const HomePage = () => (
  <div>
    <h1>Welcome</h1>
    <MyComponent />
  </div>
);

export default HomePage;
"""

### Standard 8.2: Image Optimization

**Do This:**  Use the Next.js "<Image>" component or a dedicated image optimization library to optimize images for different devices and screen sizes.  Leverage Vercel's automatic image optimization feature.

**Don't Do This:**  Serve large, unoptimized images that slow down page load times.

**Why:** Image optimization reduces the amount of data that needs to be transferred and improves page load times.

**Example:**

"""jsx
import Image from 'next/image';

const MyImage = () => (
  <Image
    src="/images/my-image.jpg"
    alt="My Image"
    width={500}
    height={300}
    priority // Use priority for LCP images
  />
);

export default MyImage;
"""

### Standard 8.3: Memoization Techniques

**Do This:**  Use "React.memo" to memoize functional components and prevent unnecessary re-renders. Use "useMemo" and "useCallback" hooks to memoize values and functions.

**Don't Do This:**  Rely solely on manual optimization without using memoization techniques.

**Why:**  Memoization prevents unnecessary re-renders and improves performance.

**Example:**

"""jsx
import React from 'react';

const MyComponent = React.memo(({ data }) => {
  // This component will only re-render if the 'data' prop changes
  console.log('Rendering MyComponent');
  return <div>{data}</div>;
});

export default MyComponent;
"""

## 9. Security

### Standard 9.1: Input Validation

**Do This**: Validate all user inputs on both the client-side and server-side to prevent attacks such as SQL injection and cross-site scripting (XSS).

**Don't Do This**: Trust user input without validation. Rely solely on client-side validation.

**Why**: Input validation ensures data is sanitized and conforms to expected formats, preventing malicious data from being processed.

**Example**:

"""javascript
// Server-side validation in a Next.js API route
export default async function handler(req, res) {
  if (req.method === 'POST') {
    const { email, message } = req.body;

    if (!email || !email.includes('@')) {
      return res.status(400).json({ error: 'Invalid email address' });
    }

    if (!message || message.length < 10 ) {
      return res.status(400).json({ error: 'Message must be at least 10 characters long' });
    }

    // Process the data if validation passes
    try {
      // Simulate saving to a database
      console.log('Data received:', { email, message });
      return res.status(200).json({ message: 'Message submitted successfully!' });
    } catch (error) {
      console.error('Error processing data:', error);
      return res.status(500).json({ error: 'Failed to process data' });
    }
  } else {
    return res.status(405).json({ error: 'Method not allowed' });
  }
}
"""

### Standard 9.2: Output Encoding

**Do This:** Encode all data that is displayed on the page to prevent XSS attacks. Use a templating engine or library that automatically encodes output.

**Don't Do This:** Output user-supplied data directly without encoding.

**Why:** Output encoding ensures that any potentially malicious code is rendered as text, preventing it from being executed in the user's browser.

**Example**:

Using React (which automatically encodes output):

"""jsx
function DisplayComment({ comment }) {
  return (
    <div>
      {/* React automatically encodes the comment content, preventing XSS */}
      <p>{comment}</p>
    </div>
  );
}

export default DisplayComment;
"""

### Standard 9.3: Environment Variables

**Do This:** Store sensitive information (e.g., API keys, database passwords) in environment variables and access them securely. Use Vercel's environment variable management feature to store and manage environment variables.

**Don't Do This:** Hardcode sensitive information in the codebase.  Commit sensitive information to version control.

**Why:** Environment variables keep sensitive information separate from the codebase, minimizing the risk of accidental exposure.

**Example:**

Accessing an environment variable in a Next.js API route:

"""javascript
// pages/api/data.js
export default async function handler(req, res) {
  const apiKey = process.env.API_KEY;

  if (!apiKey) {
    console.error('API_KEY not found in environment variables');
    return res.status(500).json({ error: 'API_KEY not configured' });
  }

  try {
    const data = await fetchData(apiKey);
    res.status(200).json(data);
  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Failed to fetch data' });
  }
}
"""

## 10. Vercel Specific Considerations

### Standard 10.1: Utilizing Vercel's Build Cache

**Do This:** Ensure your project leverages Vercel's build cache effectively.  Configure the ".vercelignore" file to exclude unnecessary files from the build cache, improving build times.  Use caching headers properly for static assets.

**Don't Do This:**  Inadvertently invalidate the build cache by including dynamic data or large, frequently changing files in the build.

**Why:** Vercel's build cache significantly speeds up deployment times, especially for large projects.

### Standard 10.2: Monitoring and Analytics

**Do This:** Utilize Vercel Analytics, or integrate with other analytics platforms to monitor application performance, identify bottlenecks, and track key metrics.  Monitor serverless function usage and optimize accordingly.

**Don't Do This:**  Deploy code without monitoring performance and usage patterns. Ignore performance alerts.

**Why:** Monitoring and analytics provide valuable insights into application behavior and help identify areas for optimization. Vercel analytics helps understand user engagement and performance metrics directly within the Vercel platform.

### Standard 10.3: Vercel CLI

**Do This:** Utilize the Vercel CLI for local development, preview deployments, and production deployments.

**Don't Do This:** Manually deploy code without using the Vercel CLI.

**Why:** Vercel CLI simplifies the deployment process and provides a consistent development experience.

By adhering to these comprehensive component design standards, development teams can create high-quality, scalable, and maintainable Vercel applications. This document provides a solid foundation for promoting best practices and ensuring consistency throughout the development lifecycle.
